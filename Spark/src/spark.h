/*
                                Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS
*/

#ifndef __SPARK_H__
#define __SPARK_H__

#include <assert.h>

#ifdef _WIN32
#define _WIN32_WINNT 0x0600
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#pragma comment(lib, "Ws2_32.lib")
#else
#include <pthread.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/types.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(_WIN32) && defined(_GLFW_BUILD_DLL)
/* We are building SPARKAPI as a Win32 DLL */
#define SPARKAPI __declspec(dllexport)
#elif defined(_WIN32) && defined(GLFW_DLL)
/* We are calling a SPARKAPI Win32 DLL */
#define SPARKAPI __declspec(dllimport)
#elif defined(__GNUC__) && defined(_GLFW_BUILD_DLL)
/* We are building SPARKAPI as a Unix shared library */
#define SPARKAPI __attribute__((visibility("default")))
#else
#define SPARKAPI
#endif

#ifdef SPARK_FAST_CALL
#define SPARKCALL __fastcall
#elif defined(SPARK_STD_CALL)
#define SPARKCALL __stdcall
#elif defined(SPARK_C_CALL)
#define SPARKCALL __cdecl
#else
#define SPARKCALL
#endif

#define SPARKSTATIC static

#define SPARK_VERSION_MAJOR 1
#define SPARK_VERSION_MINOR 0
#define SPARK_VERSION_PATCH 0

#define SPARK_SERIALIZER_MAGIC 0x53504152 // 'SPAR' in hexadecimal
#define SPARK_SERIALIZER_VERSION 1

#define SPARK_MAKE_VERSION(major, minor, patch)                                \
  ((major << 22) | (minor << 12) | patch)

#define SPARK_VERSION                                                          \
  SPARK_MAKE_VERSION(SPARK_VERSION_MAJOR, SPARK_VERSION_MINOR,                 \
                     SPARK_VERSION_PATCH)

#define SPARK_IS_VERSION(version) (version == SPARK_VERSION)
#define SPARK_IS_VERSION_OR_GREATER(version) (version >= SPARK_VERSION)
#define SPARK_IS_VERSION_OR_LOWER(version) (version <= SPARK_VERSION)

#define SPARK_MAKE_VERSION_STRING(major, minor, patch)                         \
  #major "." #minor "." #patch

#define SPARK_VERSION_STRING                                                   \
  SPARK_MAKE_VERSION_STRING(SPARK_VERSION_MAJOR, SPARK_VERSION_MINOR,          \
                            SPARK_VERSION_PATCH)

#if !defined(SPARK_NO_DEBUG) && !defined(NDEBUG) && !defined(RELEASE)
#define SPARK_LOG_DEBUG(message, ...)                                          \
  SparkLog(SPARK_LOG_LEVEL_DEBUG, message, ##__VA_ARGS__)
#else
#define SPARK_LOG_DEBUG(message, ...)
#endif
#ifndef SPARK_NO_INFO
#define SPARK_LOG_INFO(message, ...)                                           \
  SparkLog(SPARK_LOG_LEVEL_INFO, message, ##__VA_ARGS__)
#else
#define SPARK_LOG_INFO(message, ...)
#endif
#ifndef SPARK_NO_WARN
#define SPARK_LOG_WARN(message, ...)                                           \
  SparkLog(SPARK_LOG_LEVEL_WARN, message, ##__VA_ARGS__)
#else
#define SPARK_LOG_WARN(message, ...)
#endif
#ifndef SPARK_NO_ERROR
#define SPARK_LOG_ERROR(message, ...)                                          \
  SparkLog(SPARK_LOG_LEVEL_ERROR, message, ##__VA_ARGS__)
#else
#define SPARK_LOG_ERROR(message, ...)
#endif

// Default serialization function when size is not provided
// Helper Macros
#define SparkSerializeString(serializer, data) \
    SparkSerializeData(serializer, (const char*)(unsigned long long)data, strlen((const char*)(unsigned long long)data))

#define SparkSerializeTrivialType(serializer, data) \
    SparkSerializeTrivial(serializer, &(data), sizeof(data))

// SparkSerializeDefault Macro Using _Generic
#define SparkSerializeDefault(serializer, data) \
    _Generic((data), \
        const char* : SparkSerializeString(serializer, data), \
		char* : SparkSerializeString(serializer, data), \
        default: SparkSerializeTrivialType(serializer, data) \
    )

// Serialization Function When Size is Provided
#define SparkSerializeWithSize(serializer, data, size) \
    SparkSerializeData(serializer, data, size)

// Helper Macro to Select the Appropriate Serialization Function Based on Argument Count
#define GET_SPARKSERIALIZE(_1, _2, _3, NAME, ...) NAME

// Main SparkSerialize Macro
#define SparkSerialize(...) \
    GET_SPARKSERIALIZE(__VA_ARGS__, SparkSerializeWithSize, SparkSerializeDefault)(__VA_ARGS__)

#define SparkDeserializeDefault(deserializer, data) \
	SparkDeserializeTrivial(deserializer, &(data), sizeof(data))

#define SparkDeserializeWithSize(deserializer, data, size) \
	_Generic((data), \
		char* : SparkDeserializeString(deserializer, &(data), &(size)), \
		const char* : SparkDeserializeString(deserializer, &(data), &(size)), \
		default: SparkDeserializeData(deserializer, &(data), &(size)) \
	)
#define GET_SPARKDESERIALIZE(_1, _2, _3, NAME, ...) NAME

#define SparkDeserialize(...) \
	GET_SPARKDESERIALIZE(__VA_ARGS__, SparkDeserializeWithSize, SparkDeserializeDefault)(__VA_ARGS__)
	

/* Capabilities */
#define SPARK_DEPTH_TEST 0x0B71
#define SPARK_BLEND 0x0BE2
#define SPARK_CULL_FACE 0x0B44
#define SPARK_SCISSOR_TEST 0x0C11

/* Clear mask bits */
#define SPARK_COLOR_BUFFER_BIT 0x00004000
#define SPARK_DEPTH_BUFFER_BIT 0x00000100
#define SPARK_STENCIL_BUFFER_BIT 0x00000400

#define SPARK_PACKET_MAX_SIZE 4096

/*#ifdef __cplusplus
extern "C" {
#endif
*/

#pragma region TYPES

typedef unsigned char SparkU8;
typedef char SparkI8;
typedef unsigned short SparkU16;
typedef short SparkI16;
typedef unsigned int SparkU32;
typedef int SparkI32;
typedef unsigned long long SparkU64;
typedef long long SparkI64;
typedef float SparkF32;
typedef double SparkF64;
typedef SparkU8 SparkBool;
typedef SparkI32 SparkResult;
typedef void SparkVoid;
typedef void* SparkHandle;
typedef char* SparkString;
typedef const char* SparkConstString;
typedef SparkU8* SparkBuffer;
typedef const SparkU8* SparkConstBuffer;
typedef SparkU64 SparkSize;
typedef SparkU32 SparkIndex;
typedef SparkU32 SparkCount;
typedef SparkU32 SparkOffset;
typedef SparkU32 SparkTime;
typedef SparkU32 SparkDuration;
typedef SparkU32 SparkFrequency;
typedef SparkU32 SparkRate;
typedef SparkU64 SparkEventType;

#ifdef _WIN32
#include <windows.h>
typedef HANDLE SparkThread;
typedef CRITICAL_SECTION SparkMutex;
typedef CONDITION_VARIABLE SparkCondition;
#else
#include <pthread.h>
typedef pthread_t SparkThread;
typedef pthread_mutex_t SparkMutex;
typedef pthread_cond_t SparkCondition;
#endif

#define SPARK_EVENT_NONE ((SparkEventType)0x0ULL)
#define SPARK_EVENT_WINDOW_CLOSE ((SparkEventType)0x1ULL)
#define SPARK_EVENT_WINDOW_RESIZE ((SparkEventType)0x1ULL << 1)
#define SPARK_EVENT_WINDOW_FOCUS ((SparkEventType)0x1ULL << 2)
#define SPARK_EVENT_WINDOW_LOST_FOCUS ((SparkEventType)0x1ULL << 3)
#define SPARK_EVENT_WINDOW_MOVED ((SparkEventType)0x1ULL << 4)
#define SPARK_EVENT_KEY_PRESSED ((SparkEventType)0x1ULL << 5)
#define SPARK_EVENT_KEY_RELEASED ((SparkEventType)0x1ULL << 6)
#define SPARK_EVENT_KEY_TYPED ((SparkEventType)0x1ULL << 7)
#define SPARK_EVENT_MOUSE_BUTTON_PRESSED ((SparkEventType)0x1ULL << 8)
#define SPARK_EVENT_MOUSE_BUTTON_RELEASED ((SparkEventType)0x1ULL << 9)
#define SPARK_EVENT_MOUSE_MOVED ((SparkEventType)0x1ULL << 10)
#define SPARK_EVENT_MOUSE_SCROLLED ((SparkEventType)0x1ULL << 11)
#define SPARK_EVENT_MAX_BIT ((SparkEventType)0x1ULL << 12)
#define SPARK_EVENT_ALL 0xFFFFFFFFFFFFFFFF

#define SPARK_EVENT_TYPE_WINDOW                                                \
  SPARK_EVENT_WINDOW_CLOSE | SPARK_EVENT_WINDOW_RESIZE |                       \
      SPARK_EVENT_WINDOW_FOCUS | SPARK_EVENT_WINDOW_LOST_FOCUS |               \
      SPARK_EVENT_WINDOW_MOVED
#define SPARK_EVENT_TYPE_KEY                                                   \
  SPARK_EVENT_KEY_PRESSED | SPARK_EVENT_KEY_RELEASED | SPARK_EVENT_KEY_TYPED
#define SPARK_EVENT_TYPE_MOUSE                                                 \
  SPARK_EVENT_MOUSE_BUTTON_PRESSED | SPARK_EVENT_MOUSE_BUTTON_RELEASED |       \
      SPARK_EVENT_MOUSE_MOVED | SPARK_EVENT_MOUSE_SCROLLED

#define SPARK_TRANSFORM_COMPONENT "__TRANSFORM_COMPONENT__"
#define SPARK_MATERIAL_COMPONENT "__MATERIAL_COMPONENT__"
#define SPARK_MESH_COMPONENT "__MESH_COMPONENT__"
#define SPARK_MODEL_COMPONENT "__MODEL_COMPONENT__"
#define SPARK_RIGID_BODY_COMPONENT "__RIGID_BODY_COMPONENT__"
#define SPARK_COLLIDER_COMPONENT "__COLLIDER_COMPONENT__"
#define SPARK_CAMERA_COMPONENT "__CAMERA_COMPONENT__"

#define SPARK_PI        3.14159265358979323846
#define SPARK_TWO_PI    6.28318530717958647692
#define SPARK_HALF_PI   1.57079632679489661923
#define SPARK_QUARTER_PI 0.78539816339744830962
#define SPARK_E         2.71828182845904523536
#define SPARK_SQRT2     1.41421356237309504880
#define SPARK_SQRT3     1.73205080756887729353
#define SPARK_LN2       0.69314718055994530942
#define SPARK_LN10      2.30258509299404568402
#define SPARK_LOG2E     1.44269504088896340736
#define SPARK_LOG10E    0.43429448190325182765
#define SPARK_INV_PI    0.31830988618379067154
#define SPARK_INV_SQRT_PI 0.56418958354775628694
#define SPARK_TWO_OVER_PI 0.63661977236758134308
#define SPARK_TWO_OVER_SQRT_PI 1.12837916709551257390
#define SPARK_DEG_TO_RAD (SPARK_PI / 180.0f)
#define SPARK_RAD_TO_DEG (180.0f / SPARK_PI)

#pragma endregion

#pragma region ENUMS

typedef enum SparkType {
	SPARK_FALSE = 0,
	SPARK_TRUE = 1,
	SPARK_SUCCESS = 1,
	SPARK_FAILURE = -1,
	SPARK_ERROR = -2,
	SPARK_VALID = 1,
	SPARK_INVALID = -1,
	SPARK_NULL = 0,
	SPARK_NONE = 0,
	SPARK_UNKNOWN = -4,
	SPARK_PENDING = -5,
	SPARK_IN_PROGRESS = -6,
	SPARK_COMPLETE = 2,
	SPARK_TIMEOUT = -7,
	SPARK_CANCELLED = -8,
	SPARK_NOT_IMPLEMENTED = -9,
	SPARK_ACCESS_DENIED = -10,
	SPARK_NOT_FOUND = -11,
	SPARK_BUSY = -12,
	SPARK_OVERLOADED = -13,
	SPARK_DISCONNECTED = -14,
	SPARK_CONNECTED = 3,
	SPARK_RETRY = -15,
	SPARK_DEPRECATED = -16,
	SPARK_UNSUPPORTED = -17,
	SPARK_INITIALIZED = 4,
	SPARK_UNINITIALIZED = -18,
	SPARK_ENABLED = 5,
	SPARK_DISABLED = -19,
	SPARK_READ_ONLY = -20,
	SPARK_WRITE_ONLY = -21,
	SPARK_READ_WRITE = 6,
	SPARK_SUCCESS_PARTIAL = -22,
	SPARK_INVALID_ARGUMENT = -23,
	SPARK_OUT_OF_MEMORY = -24,
	SPARK_OVERFLOW = -25,
	SPARK_UNDERFLOW = -26,
	SPARK_END_OF_FILE = -27,
	SPARK_PERMISSION_DENIED = -28,
	SPARK_BAD_REQUEST = -29,
	SPARK_CONFLICT = -30,
	SPARK_PRECONDITION_FAILED = -31
} SparkType;

typedef enum SparkError {
	SPARK_ERROR_NONE = 0,
	SPARK_ERROR_UNKNOWN = -1,
	SPARK_ERROR_INVALID = -2,
	SPARK_ERROR_NULL = -3,
	SPARK_ERROR_NOT_FOUND = -4,
	SPARK_ERROR_NOT_IMPLEMENTED = -5,
	SPARK_ERROR_ACCESS_DENIED = -6,
	SPARK_ERROR_BUSY = -7,
	SPARK_ERROR_OVERLOADED = -8,
	SPARK_ERROR_DISCONNECTED = -9,
	SPARK_ERROR_TIMEOUT = -10,
	SPARK_ERROR_CANCELLED = -11,
	SPARK_ERROR_RETRY = -12,
	SPARK_ERROR_UNSUPPORTED = -13,
	SPARK_ERROR_DEPRECATED = -14,
	SPARK_ERROR_UNINITIALIZED = -15,
	SPARK_ERROR_DISABLED = -16,
	SPARK_ERROR_READ_ONLY = -17,
	SPARK_ERROR_WRITE_ONLY = -18,
	SPARK_ERROR_OUT_OF_MEMORY = -19,
	SPARK_ERROR_OVERFLOW = -20,
	SPARK_ERROR_UNDERFLOW = -21,
	SPARK_ERROR_END_OF_FILE = -22,
	SPARK_ERROR_PERMISSION_DENIED = -23,
	SPARK_ERROR_BAD_REQUEST = -24,
	SPARK_ERROR_CONFLICT = -25,
	SPARK_ERROR_PRECONDITION_FAILED = -26,
	SPARK_ERROR_INVALID_ARGUMENT = -27,
	SPARK_ERROR_INVALID_STATE = -28,
	SPARK_ERROR_INVALID_FUNCTION_CALL = -29,
} SparkError;

typedef enum SparkAccess {
	SPARK_ACCESS_NONE = 0,
	SPARK_ACCESS_READ = 1,
	SPARK_ACCESS_WRITE = 2,
	SPARK_ACCESS_READ_WRITE = 3
} SparkAccess;

typedef enum SparkMouseButtonT {
	SPARK_MOUSE_BUTTON_1 = 0,
	SPARK_MOUSE_BUTTON_2 = 1,
	SPARK_MOUSE_BUTTON_3 = 2,
	SPARK_MOUSE_BUTTON_4 = 3,
	SPARK_MOUSE_BUTTON_5 = 4,
	SPARK_MOUSE_BUTTON_6 = 5,
	SPARK_MOUSE_BUTTON_7 = 6,
	SPARK_MOUSE_BUTTON_8 = 7,
	SPARK_MOUSE_BUTTON_LAST = SPARK_MOUSE_BUTTON_8,
	SPARK_MOUSE_BUTTON_LEFT = SPARK_MOUSE_BUTTON_1,
	SPARK_MOUSE_BUTTON_RIGHT = SPARK_MOUSE_BUTTON_2,
	SPARK_MOUSE_BUTTON_MIDDLE = SPARK_MOUSE_BUTTON_3
} SparkMouseButton;

typedef enum SparkKeyT {
	SPARK_KEY_UNKNOWN = -1,
	SPARK_KEY_SPACE = 32,
	SPARK_KEY_APOSTROPHE = 39, /* ' */
	SPARK_KEY_COMMA = 44,      /* , */
	SPARK_KEY_MINUS = 45,      /* - */
	SPARK_KEY_PERIOD = 46,     /* . */
	SPARK_KEY_SLASH = 47,      /* / */
	SPARK_KEY_0 = 48,
	SPARK_KEY_1 = 49,
	SPARK_KEY_2 = 50,
	SPARK_KEY_3 = 51,
	SPARK_KEY_4 = 52,
	SPARK_KEY_5 = 53,
	SPARK_KEY_6 = 54,
	SPARK_KEY_7 = 55,
	SPARK_KEY_8 = 56,
	SPARK_KEY_9 = 57,
	SPARK_KEY_SEMICOLON = 59, /* ; */
	SPARK_KEY_EQUAL = 61,     /* = */
	SPARK_KEY_A = 65,
	SPARK_KEY_B = 66,
	SPARK_KEY_C = 67,
	SPARK_KEY_D = 68,
	SPARK_KEY_E = 69,
	SPARK_KEY_F = 70,
	SPARK_KEY_G = 71,
	SPARK_KEY_H = 72,
	SPARK_KEY_I = 73,
	SPARK_KEY_J = 74,
	SPARK_KEY_K = 75,
	SPARK_KEY_L = 76,
	SPARK_KEY_M = 77,
	SPARK_KEY_N = 78,
	SPARK_KEY_O = 79,
	SPARK_KEY_P = 80,
	SPARK_KEY_Q = 81,
	SPARK_KEY_R = 82,
	SPARK_KEY_S = 83,
	SPARK_KEY_T = 84,
	SPARK_KEY_U = 85,
	SPARK_KEY_V = 86,
	SPARK_KEY_W = 87,
	SPARK_KEY_X = 88,
	SPARK_KEY_Y = 89,
	SPARK_KEY_Z = 90,
	SPARK_KEY_LEFT_BRACKET = 91,  /* [ */
	SPARK_KEY_BACKSLASH = 92,     /* \ */
	SPARK_KEY_RIGHT_BRACKET = 93, /* ] */
	SPARK_KEY_GRAVE_ACCENT = 96,  /* ` */
	SPARK_KEY_WORLD_1 = 161,      /* non-US #1 */
	SPARK_KEY_WORLD_2 = 162,      /* non-US #2 */

	/* Function keys */
	SPARK_KEY_ESCAPE = 256,
	SPARK_KEY_ENTER = 257,
	SPARK_KEY_TAB = 258,
	SPARK_KEY_BACKSPACE = 259,
	SPARK_KEY_INSERT = 260,
	SPARK_KEY_DELETE = 261,
	SPARK_KEY_RIGHT = 262,
	SPARK_KEY_LEFT = 263,
	SPARK_KEY_DOWN = 264,
	SPARK_KEY_UP = 265,
	SPARK_KEY_PAGE_UP = 266,
	SPARK_KEY_PAGE_DOWN = 267,
	SPARK_KEY_HOME = 268,
	SPARK_KEY_END = 269,
	SPARK_KEY_CAPS_LOCK = 280,
	SPARK_KEY_SCROLL_LOCK = 281,
	SPARK_KEY_NUM_LOCK = 282,
	SPARK_KEY_PRINT_SCREEN = 283,
	SPARK_KEY_PAUSE = 284,
	SPARK_KEY_F1 = 290,
	SPARK_KEY_F2 = 291,
	SPARK_KEY_F3 = 292,
	SPARK_KEY_F4 = 293,
	SPARK_KEY_F5 = 294,
	SPARK_KEY_F6 = 295,
	SPARK_KEY_F7 = 296,
	SPARK_KEY_F8 = 297,
	SPARK_KEY_F9 = 298,
	SPARK_KEY_F10 = 299,
	SPARK_KEY_F11 = 300,
	SPARK_KEY_F12 = 301,
	SPARK_KEY_F13 = 302,
	SPARK_KEY_F14 = 303,
	SPARK_KEY_F15 = 304,
	SPARK_KEY_F16 = 305,
	SPARK_KEY_F17 = 306,
	SPARK_KEY_F18 = 307,
	SPARK_KEY_F19 = 308,
	SPARK_KEY_F20 = 309,
	SPARK_KEY_F21 = 310,
	SPARK_KEY_F22 = 311,
	SPARK_KEY_F23 = 312,
	SPARK_KEY_F24 = 313,
	SPARK_KEY_F25 = 314,
	SPARK_KEY_KP_0 = 320,
	SPARK_KEY_KP_1 = 321,
	SPARK_KEY_KP_2 = 322,
	SPARK_KEY_KP_3 = 323,
	SPARK_KEY_KP_4 = 324,
	SPARK_KEY_KP_5 = 325,
	SPARK_KEY_KP_6 = 326,
	SPARK_KEY_KP_7 = 327,
	SPARK_KEY_KP_8 = 328,
	SPARK_KEY_KP_9 = 329,
	SPARK_KEY_KP_DECIMAL = 330,
	SPARK_KEY_KP_DIVIDE = 331,
	SPARK_KEY_KP_MULTIPLY = 332,
	SPARK_KEY_KP_SUBTRACT = 333,
	SPARK_KEY_KP_ADD = 334,
	SPARK_KEY_KP_ENTER = 335,
	SPARK_KEY_KP_EQUAL = 336,
	SPARK_KEY_LEFT_SHIFT = 340,
	SPARK_KEY_LEFT_CONTROL = 341,
	SPARK_KEY_LEFT_ALT = 342,
	SPARK_KEY_LEFT_SUPER = 343,
	SPARK_KEY_RIGHT_SHIFT = 344,
	SPARK_KEY_RIGHT_CONTROL = 345,
	SPARK_KEY_RIGHT_ALT = 346,
	SPARK_KEY_RIGHT_SUPER = 347,
	SPARK_KEY_MENU = 348
} SparkKey;

typedef enum SparkModifierT {
	SPARK_MOD_SHIFT = 0x0001,
	SPARK_MOD_CONTROL = 0x0002,
	SPARK_MOD_ALT = 0x0004,
	SPARK_MOD_SUPER = 0x0008
} SparkModifier;

typedef enum SparkActionT {
	SPARK_RELEASE = 0,
	SPARK_PRESS = 1,
	SPARK_REPEAT = 2
} SparkAction;

typedef enum SparkCursorT {
	SPARK_CURSOR_ARROW = 0,
	SPARK_CURSOR_IBEAM = 1,
	SPARK_CURSOR_CROSSHAIR = 2,
	SPARK_CURSOR_HAND = 3,
	SPARK_CURSOR_HRESIZE = 4,
	SPARK_CURSOR_VRESIZE = 5
} SparkCursor;

/* Shader types */
typedef enum SparkShaderTypeT {
	SPARK_SHADER_VERTEX = 0,
	SPARK_SHADER_FRAGMENT,
	SPARK_SHADER_GEOMETRY,
	SPARK_SHADER_TESSELLATION_CONTROL,
	SPARK_SHADER_TESSELLATION_EVALUATION,
	SPARK_SHADER_COMPUTE
} SparkShaderType;

/* Primitive types */
typedef enum SparkPrimitiveTypeT {
	SPARK_PRIMITIVE_POINTS = 0,
	SPARK_PRIMITIVE_LINES,
	SPARK_PRIMITIVE_LINE_STRIP,
	SPARK_PRIMITIVE_TRIANGLES,
	SPARK_PRIMITIVE_TRIANGLE_STRIP,
	SPARK_PRIMITIVE_TRIANGLE_FAN
} SparkPrimitiveType;

/* Blend modes */
typedef enum SparkBlendModeT {
	SPARK_BLEND_ZERO = 0,
	SPARK_BLEND_ONE,
	SPARK_BLEND_SRC_COLOR,
	SPARK_BLEND_ONE_MINUS_SRC_COLOR,
	SPARK_BLEND_DST_COLOR,
	SPARK_BLEND_ONE_MINUS_DST_COLOR,
	SPARK_BLEND_SRC_ALPHA,
	SPARK_BLEND_ONE_MINUS_SRC_ALPHA,
	SPARK_BLEND_DST_ALPHA,
	SPARK_BLEND_ONE_MINUS_DST_ALPHA,
	SPARK_BLEND_CONSTANT_COLOR,
	SPARK_BLEND_ONE_MINUS_CONSTANT_COLOR,
	SPARK_BLEND_CONSTANT_ALPHA,
	SPARK_BLEND_ONE_MINUS_CONSTANT_ALPHA,
	SPARK_BLEND_SRC_ALPHA_SATURATE
} SparkBlendMode;

/* Texture filtering options */
typedef enum SparkTextureFilterT {
	SPARK_TEXTURE_FILTER_NEAREST = 0,
	SPARK_TEXTURE_FILTER_LINEAR,
	SPARK_TEXTURE_FILTER_NEAREST_MIPMAP_NEAREST,
	SPARK_TEXTURE_FILTER_LINEAR_MIPMAP_NEAREST,
	SPARK_TEXTURE_FILTER_NEAREST_MIPMAP_LINEAR,
	SPARK_TEXTURE_FILTER_LINEAR_MIPMAP_LINEAR
} SparkTextureFilter;

/* Log levels */
typedef enum SparkLogLevelT {
	SPARK_LOG_LEVEL_TRACE = 0,
	SPARK_LOG_LEVEL_DEBUG,
	SPARK_LOG_LEVEL_INFO,
	SPARK_LOG_LEVEL_WARN,
	SPARK_LOG_LEVEL_ERROR,
	SPARK_LOG_LEVEL_FATAL
} SparkLogLevel;

/* Render APIs */
typedef enum SparkRenderAPIT {
	SPARK_RENDER_API_NONE = 0,
	SPARK_RENDER_API_OPENGL,
	SPARK_RENDER_API_VULKAN,
	SPARK_RENDER_API_DIRECTX,
	SPARK_RENDER_API_METAL
} SparkRenderAPI;

/* Shader data types */
typedef enum SparkShaderDataTypeT {
	SPARK_SHADER_DATA_TYPE_FLOAT,
	SPARK_SHADER_DATA_TYPE_VEC2,
	SPARK_SHADER_DATA_TYPE_VEC3,
	SPARK_SHADER_DATA_TYPE_VEC4,
	SPARK_SHADER_DATA_TYPE_INT,
	SPARK_SHADER_DATA_TYPE_IVEC2,
	SPARK_SHADER_DATA_TYPE_IVEC3,
	SPARK_SHADER_DATA_TYPE_IVEC4,
	SPARK_SHADER_DATA_TYPE_MAT2,
	SPARK_SHADER_DATA_TYPE_MAT3,
	SPARK_SHADER_DATA_TYPE_MAT4,
	SPARK_SHADER_DATA_TYPE_SAMPLER2D
} SparkShaderDataType;

typedef enum SparkEnvelopeTypeT {
	SPARK_ENVELOPE_TYPE_DATA = 0,
	SPARK_ENVELOPE_TYPE_COMMAND,
	SPARK_ENVELOPE_TYPE_RESPONSE,
} SparkEnvelopeType;

#pragma endregion

#pragma region STRUCTS

typedef struct SparkEventDataKeyPressedT {
	SparkKey key;
	SparkI32 repeat;
} *SparkEventDataKeyPressed;

typedef struct SparkEventDataKeyReleasedT {
	SparkKey key;
} *SparkEventDataKeyReleased;

typedef struct SparkEventDataMouseMovedT {
	SparkF64 xpos;
	SparkF64 ypos;
} *SparkEventDataMouseMoved;

typedef struct SparkEventDataMouseButtonPressedT {
	SparkMouseButton button;
} *SparkEventDataMouseButtonPressed;

typedef struct SparkEventDataMouseButtonReleasedT {
	SparkMouseButton button;
} *SparkEventDataMouseButtonReleased;

typedef struct SparkEventDataMouseScrolledT {
	SparkF64 x;
	SparkF64 y;
} *SparkEventDataMouseScrolled;

typedef struct SparkEventDataWindowResizedT {
	SparkI32 width;
	SparkI32 height;
} *SparkEventDataWindowResized;

typedef SparkF32 SparkScalar;
typedef SparkI32 SparkIScalar;

/* Forward declaration of Ecs */
struct SparkEcsT;

typedef struct SparkVector2T {
	SparkScalar x;
	SparkScalar y;
} SparkVec2;

typedef struct SparkVector3T {
	SparkScalar x;
	SparkScalar y;
	SparkScalar z;
} SparkVec3;

typedef struct SparkVector4T {
	SparkScalar x;
	SparkScalar y;
	SparkScalar z;
	SparkScalar w;
} SparkVec4;

typedef struct SparkMatrix2T {
	SparkScalar m00, m01;
	SparkScalar m10, m11;
} SparkMat2;

typedef struct SparkMatrix3T {
	SparkScalar m00, m01, m02;
	SparkScalar m10, m11, m12;
	SparkScalar m20, m21, m22;
} SparkMat3;

typedef struct SparkMatrix4T {
	SparkScalar m00, m01, m02, m03;
	SparkScalar m10, m11, m12, m13;
	SparkScalar m20, m21, m22, m23;
	SparkScalar m30, m31, m32, m33;
} SparkMat4;

typedef struct SparkQuaternionT {
	SparkScalar x;
	SparkScalar y;
	SparkScalar z;
	SparkScalar w;
} SparkQuat;

typedef struct SparkIVector2T {
	SparkIScalar x;
	SparkIScalar y;
} SparkIVec2;

typedef struct SparkIVector3T {
	SparkIScalar x;
	SparkIScalar y;
	SparkIScalar z;
} SparkIVec3;

typedef struct SparkIVector4T {
	SparkIScalar x;
	SparkIScalar y;
	SparkIScalar z;
	SparkIScalar w;
} SparkIVec4;

typedef struct SparkColorT {
	SparkScalar r;
	SparkScalar g;
	SparkScalar b;
	SparkScalar a;
} SparkColor;

typedef struct SparkRectT {
	SparkScalar x;
	SparkScalar y;
	SparkScalar width;
	SparkScalar height;
} SparkRect;

typedef struct SparkCircleT {
	SparkScalar x;
	SparkScalar y;
	SparkScalar radius;
} SparkCircle;

typedef struct SparkLineT {
	SparkScalar x1;
	SparkScalar y1;
	SparkScalar x2;
	SparkScalar y2;
} SparkLine;

typedef struct SparkTriangleT {
	SparkScalar x1;
	SparkScalar y1;
	SparkScalar x2;
	SparkScalar y2;
	SparkScalar x3;
	SparkScalar y3;
} SparkTriangle;

typedef struct SparkQuadT {
	SparkScalar x1;
	SparkScalar y1;
	SparkScalar x2;
	SparkScalar y2;
	SparkScalar x3;
	SparkScalar y3;
	SparkScalar x4;
	SparkScalar y4;
} SparkQuad;

typedef SparkHandle(*SparkAllocateFunction)(SparkSize size);
typedef SparkHandle(*SparkReallocateFunction)(SparkHandle handle,
	SparkSize size);
typedef SparkVoid(*SparkFreeFunction)(SparkHandle handle);
typedef SparkSize(*SparkHashFunction)(SparkConstBuffer buf, SparkSize length);
typedef SparkResult(*SparkSystemStartFunction)(struct SparkEcsT* ecs);
typedef SparkResult(*SparkSystemUpdateFunction)(struct SparkEcsT* ecs,
	SparkF32 delta);
typedef SparkResult(*SparkSystemStopFunction)(struct SparkEcsT* ecs);
typedef SparkI32(*SparkCompareFunction)(SparkHandle a, SparkSize a_size,
	SparkHandle b, SparkSize b_size);
typedef SparkHandle(*SparkThreadFunction)(SparkHandle arg);

typedef SparkVoid(*SparkApplicationStartFunction)(
	struct SparkApplicationT* app);
typedef SparkVoid(*SparkApplicationUpdateFunction)(
	struct SparkApplicationT* app);
typedef SparkVoid(*SparkApplicationStopFunction)(
	struct SparkApplicationT* app);
typedef SparkVoid(*SparkApplicationEventFunction)(
	struct SparkApplicationT* app, struct SparkEventT event);
typedef SparkVoid(*SparkApplicationQueryFunction)(
	struct SparkApplicationT* app, struct SparkVectorT* query);
typedef SparkVoid(*SparkApplicationQueryEventFunction)(
	struct ApplicationT* app, struct SparkVectorT* query,
	struct SparkEventT event);
typedef SparkVoid(*SparkServerReceiveCallback)(struct SparkServerT* server, struct SparkClientConnectionT* client, struct SparkEnvelopeT* envelope);
typedef SparkVoid(*SparkClientReceiveCallback)(struct SparkClientT* client, struct SparkEnvelopeT* envelope);


typedef struct SparkAllocatorT {
	SparkAllocateFunction allocate;
	SparkReallocateFunction reallocate;
	SparkFreeFunction free;
} *SparkAllocator;

typedef struct SparkVectorT {
	SparkSize size;
	SparkSize capacity;
	/* Destructor to be called on each element */
	SparkFreeFunction destructor;
	SparkHandle* elements;
	SparkAllocator allocator;
	SparkBool external_allocator;
} *SparkVector;

typedef struct SparkListNodeT {
	SparkHandle data;
	struct SparkListNodeT* next;
} *SparkListNode;

typedef struct SparkListT {
	SparkSize size;
	/* Destructor to be called on each element */
	SparkFreeFunction destructor;
	SparkListNode head;
	SparkListNode tail;
	SparkAllocator allocator;
	SparkBool external_allocator;
} *SparkList;

typedef struct SparkHashMapNodeT {
	SparkHandle key;
	SparkHandle value;
	SparkSize key_size;
	SparkSize hash;
	struct SparkHashMapNodeT* next;
} *SparkHashMapNode;

typedef struct SparkHashMapT {
	SparkAllocator allocator;
	SparkSize capacity;
	SparkSize size;
	SparkHashMapNode* buckets;
	SparkHashFunction hash_function;
	SparkCompareFunction compare_function;
	SparkFreeFunction key_destructor;
	SparkFreeFunction value_destructor;
	SparkBool external_allocator;
} *SparkHashMap;

typedef struct SparkMapT {
	SparkSize size;
	SparkHandle root;
	SparkAllocator allocator;
} *SparkMap;

typedef struct SparkSetT {
	SparkAllocator allocator;
	SparkSize capacity;
	SparkSize size;
	SparkFreeFunction destructor;
	SparkHandle* elements;
	SparkBool external_allocator;
} *SparkSet;

typedef struct SparkHashSetT {
	SparkAllocator allocator;
	SparkSize capacity;
	SparkSize size;
	SparkSize element_size;
	SparkFreeFunction destructor;
	SparkHandle* elements;
	SparkSize* hashes;
	SparkHashFunction hash_function;
	SparkBool external_allocator;
} *SparkHashSet;

typedef struct SparkQueueT {
	SparkAllocator allocator;
	SparkSize capacity;
	SparkSize size;
	SparkSize front;
	SparkSize rear;
	SparkFreeFunction destructor;
	SparkHandle* elements;
	SparkBool external_allocator;
} *SparkQueue;

typedef struct SparkStackT {
	SparkAllocator allocator;
	SparkSize capacity;
	SparkSize size;
	SparkFreeFunction destructor;
	SparkHandle* elements;
	SparkBool external_allocator;
} *SparkStack;

typedef struct SparkTaskT {
	SparkThreadFunction function;
	SparkHandle arg;
	SparkHandle result;
	struct SparkTaskT* next;
	SparkMutex mutex;
	SparkCondition cond;
	SparkI32 is_done;
} *SparkTaskHandle;

typedef struct SparkThreadPoolT {
	SparkThread* threads;
	SparkSize thread_count;
	SparkTaskHandle task_queue_head;
	SparkTaskHandle task_queue_tail;
	SparkMutex mutex;
	SparkCondition condition;
	SparkI32 stop;
} *SparkThreadPool;

typedef struct SparkEventT {
	SparkEventType type;
	SparkHandle data;
	SparkConstString timestamp;
	SparkFreeFunction destructor;
} SparkEvent;

typedef struct SparkEventHandlerFunctionT {
	SparkEventType event_type;
	SparkApplicationEventFunction function;
} *SparkEventHandlerFunction;

typedef struct SparkQueryEventHandlerFunctionT {
	SparkEventType event_type;
	SparkConstString component_type;
	SparkApplicationQueryEventFunction function;
} *SparkQueryEventHandlerFunction;

typedef struct SparkEventHandlerT {
	/* Vector <SparkEventHandlerFunction> */
	SparkVector event_functions;
	/* HashMap <SparkConstString, SparkVector <SparkQueryEventHandlerFunction>> */
	SparkHashMap query_functions;
	struct SparkApplicationT* application;
	struct SparkEcsT* ecs;
} *SparkEventHandler;

typedef SparkI32 SparkEntity;

typedef struct SparkComponentT {
	SparkConstString type;
	SparkConstString name;
	SparkHandle data;
	SparkFreeFunction destructor;
	/* Parent entity of this component */
	SparkEntity entity;
} *SparkComponent;

typedef struct SparkComponentArrayT {
	SparkHashMap entity_to_component; // HashMap of entity IDs to components
} *SparkComponentArray;

typedef struct SparkSystemT {
	SparkSystemStartFunction start;
	SparkSystemUpdateFunction update;
	SparkSystemStopFunction stop;
	SparkEventHandler event_handler;
	SparkHandle system_data;
} *SparkSystem;

typedef struct SparkEcsT {
	SparkAllocator allocator;
	/* Vector <SparkEntity> */
	SparkVector entities;
	/* Vector <SparkSystem> */
	SparkVector systems;
	/* HashMap <SparkString, SparkComponentArray> */
	SparkHashMap components;
	/* Stack <SparkI32> */
	SparkStack recycled_ids;
	SparkEventHandler event_handler;
} *SparkEcs;

typedef struct SparkResourceT {
	SparkConstString name;
	SparkConstString type;
	SparkHandle data;
} *SparkResource;

typedef struct SparkResourceLoaderT {
	SparkConstString type;
	SparkHandle(*load)(SparkConstString path);
	SparkResult(*unload)(SparkHandle handle);
} *SparkResourceLoader;

typedef struct SparkResourceRegistryT {
	/* HashMap <SparkString, SparkResourceLoader> */
	SparkHashMap loaders;
	/* HashMap <SparkString, SparkResource> */
	SparkHashMap resources;
} *SparkResourceRegistry;

typedef struct SparkWindowDataT {
	SparkConstString title;
	SparkI32 width;
	SparkI32 height;
	SparkBool vsync;
	SparkEventHandler event_handler;
} *SparkWindowData;

typedef struct SparkRendererT {
	SparkI8 not_implemented;
} *SparkRenderer;


/* Physics-related declarations */
typedef struct SparkRigidBodyT {
	SparkVec3 position;
	SparkVec3 velocity;
	SparkVec3 acceleration;
	SparkQuat rotation;
	SparkScalar mass;
	SparkScalar friction;
	SparkScalar restitution; \
} *SparkRigidBody;

typedef struct SparkColliderT {
	enum {
		SPARK_COLLIDER_TYPE_BOX,
		SPARK_COLLIDER_TYPE_SPHERE,
		SPARK_COLLIDER_TYPE_CAPSULE,
		SPARK_COLLIDER_TYPE_MESH,
	} type;
	// Collider-specific data
	union {
		struct {
			SparkVec3 half_extents;
		} box;
		struct {
			SparkScalar radius;
		} sphere;
		// Other collider-specific structures
	} data;
} *SparkCollider;

/* Input handling declarations */
typedef struct SparkInputT {
	SparkBool keys[1024];
	SparkBool mouseButtons[32];
	SparkScalar mousex;
	SparkScalar mousey;
} *SparkInput;

/* Audio-related declarations */
typedef struct SparkAudioBufferT* SparkAudioBuffer;
typedef struct SparkAudioSourceT* SparkAudioSource;

/* Scene management declarations */
typedef struct SparkSceneNodeT {
	SparkEntity entity;
	struct SparkSceneNodeT* parent;
	SparkVector children; // Vector of SparkSceneNode
} *SparkSceneNode;

typedef struct SparkSceneT {
	SparkSceneNode root;
} *SparkScene;

/* Animation declarations */
typedef struct SparkAnimationT {
	SparkI8 unimplemented;
} *SparkAnimation;

/* GUI declarations */
typedef struct SparkGuiElementT* SparkGuiElement;
typedef struct SparkGuiStyleT* SparkGuiStyle;

/* AI-related declarations */
typedef struct SparkAIBehaviorT* SparkAIBehavior;

/* Particle system declarations */
typedef struct SparkParticleEmitterT* SparkParticleEmitter;

/* Font and text rendering declarations */
typedef struct SparkFontT* SparkFont;
typedef struct SparkTextT {
	SparkConstString content;
	SparkFont font;
	SparkScalar size;
	SparkColor color;
	SparkVec2 position;
} SparkText;


/* Packet Structure */
typedef struct SparkPacketT {
	SparkSize size;
	SparkBuffer data;
} SparkPacket;

/* Envelope Structure */
typedef struct SparkEnvelopeT {
	SparkEnvelopeType type;
	SparkPacket packet;
} SparkEnvelope;

/* Forward declarations */
typedef struct SparkServerT* SparkServer;
typedef struct SparkClientT* SparkClient;
typedef struct SparkClientConnectionT* SparkClientConnection;

typedef struct SparkFileDeserializerT {
	SparkU8* data;
	SparkU64 size;
	SparkU64 capacity;
	SparkConstString path; 
	SparkU64 curr_off;
	FILE* file;
} *SparkFileDeserializer;

typedef struct SparkFileSerializerT {
	SparkU8* data;
	SparkU64 size;
	SparkU64 capacity;
	SparkConstString path;
	FILE* file;
} *SparkFileSerializer;

typedef struct SparkWindowT {
	SparkWindowData window_data;
	SparkRenderer renderer;
#ifdef SPARK_IMPLEMENTATION
	struct GLFWwindow* window;
	struct VkInstance_T* instance;
	struct VkDebugUtilsMessengerEXT_T* debug_messenger;
	struct VkPhysicalDevice_T* physical_device;
	struct VkDevice_T* device;
	struct VkQueue_T* graphics_queue;
	struct VkQueue_T* present_queue;
	struct VkSufraceKHR_T* surface;
	struct VkSwapchainKHR_T* swap_chain;
	struct VkImage_T** swap_chain_images;
	struct VkImageView_T** swap_chain_image_views;
	struct VkExtent2D* swap_chain_extent;
	struct VkFramebuffer_T** swap_chain_framebuffers;
	struct VkPipelineLayout_T* pipeline_layout;
	struct VkRenderPass_T* render_pass;
	struct VkPipeline_T* graphics_pipeline;
	struct VkCommandPool_T* command_pool;
	struct VkCommandBuffer_T* command_buffer;
	struct VkSemaphore_T* image_available_semaphore;
	struct VkSemaphore_T* render_finished_semaphore;
	struct VkFence_T* in_flight_fence;
	enum VkFormat swap_chain_image_format;
	SparkU32 swap_chain_images_size;
	SparkU32 swap_chain_image_views_size;
#endif
} *SparkWindow;

typedef struct SparkApplicationT {
	SparkWindow window;
	SparkEcs ecs;
	SparkResourceRegistry resource_registry;
	SparkEventHandler event_handler;
	/* Vector <SparkApplicationStartFunction> */
	SparkVector start_functions;
	/* Vector <SparkApplicationUpdateFunction> */
	SparkVector update_functions;
	/* Vector <SparkApplicationStopFunction> */
	SparkVector stop_functions;
	/* Vector <SparkApplicationEventFunction> */
	SparkVector event_functions;
	/* HashMap <SparkConstString, SparkVector <SparkApplicationQueryFunction>> */
	SparkHashMap query_functions;
	/* Vector <SparkApplicationQueryEventFunction> */
	SparkVector query_event_functions;
	SparkThreadPool thread_pool;
	SparkF32 delta_time;
} *SparkApplication;

#pragma endregion

#pragma region FUNCTIONS

SPARKAPI SparkConstString SPARKCALL SparkTypeToString(SparkType type);
SPARKAPI SparkType SPARKCALL SparkStringToType(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkErrorToString(SparkError error);
SPARKAPI SparkError SPARKCALL SparkStringToError(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkResultToString(SparkResult result);
SPARKAPI SparkResult SPARKCALL SparkStringToResult(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkAccessToString(SparkAccess access);
SPARKAPI SparkAccess SPARKCALL SparkStringToAccess(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkMouseButtonToString(SparkMouseButton button);
SPARKAPI SparkMouseButton SPARKCALL SparkStringToMouseButton(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkKeyToString(SparkKey key);
SPARKAPI SparkKey SPARKCALL SparkStringToKey(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkModifierToString(SparkModifier modifier);
SPARKAPI SparkModifier SPARKCALL SparkStringToModifier(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkActionToString(SparkAction action);
SPARKAPI SparkAction SPARKCALL SparkStringToAction(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkCursorToString(SparkCursor cursor);
SPARKAPI SparkCursor SPARKCALL SparkStringToCursor(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkEventTypeToString(SparkEventType eventType);
SPARKAPI SparkEventType SPARKCALL SparkStringToEventType(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkShaderTypeToString(SparkShaderType shaderType);
SPARKAPI SparkShaderType SPARKCALL SparkStringToShaderType(SparkConstString string);
SPARKAPI SparkConstString
SPARKCALL SparkPrimitiveTypeToString(SparkPrimitiveType primitiveType);
SPARKAPI SparkPrimitiveType SPARKCALL SparkStringToPrimitiveType(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkBlendModeToString(SparkBlendMode blendMode);
SPARKAPI SparkBlendMode SPARKCALL SparkStringToBlendMode(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkTextureFilterToString(SparkTextureFilter filter);
SPARKAPI SparkTextureFilter SPARKCALL SparkStringToTextureFilter(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkLogLevelToString(SparkLogLevel level);
SPARKAPI SparkLogLevel SPARKCALL SparkStringToLogLevel(SparkConstString string);
SPARKAPI SparkConstString SPARKCALL SparkRenderAPIToString(SparkRenderAPI api);
SPARKAPI SparkRenderAPI SPARKCALL SparkStringToRenderAPI(SparkConstString string);

SPARKAPI SparkConstString SPARKCALL SparkFormatString(SparkConstString format, ...);
SPARKAPI SparkConstString SPARKCALL SparkGetTime();

SPARKAPI SparkVoid SPARKCALL SparkLog(SparkLogLevel log_level, SparkConstString format,
	...);

#pragma region MATH

#ifdef near
#undef near
#endif

#ifdef far
#undef far
#endif


SPARKAPI SparkVec2 SPARKCALL SparkVec2Add(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Subtract(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Multiply(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Divide(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Scale(SparkVec2 a, SparkScalar s);
SPARKAPI SparkScalar SPARKCALL SparkVec2Dot(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkScalar SPARKCALL SparkVec2Length(SparkVec2 a);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Normalize(SparkVec2 a);
SPARKAPI SparkScalar SPARKCALL SparkVec2Distance(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Negate(SparkVec2 a);
SPARKAPI SparkScalar SPARKCALL SparkVec2Angle(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Reflect(SparkVec2 v, SparkVec2 n);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Lerp(SparkVec2 a, SparkVec2 b, SparkScalar t);

SPARKAPI SparkVec3 SPARKCALL SparkVec3Add(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Subtract(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Multiply(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Divide(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Scale(SparkVec3 a, SparkScalar s);
SPARKAPI SparkScalar SPARKCALL SparkVec3Dot(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Cross(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkScalar SPARKCALL SparkVec3Length(SparkVec3 a);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Normalize(SparkVec3 a);
SPARKAPI SparkScalar SPARKCALL SparkVec3Distance(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Negate(SparkVec3 a);
SPARKAPI SparkScalar SPARKCALL SparkVec3Angle(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Reflect(SparkVec3 v, SparkVec3 n);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Lerp(SparkVec3 a, SparkVec3 b, SparkScalar t);

SPARKAPI SparkVec4 SPARKCALL SparkVec4Add(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Subtract(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Multiply(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Divide(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Scale(SparkVec4 a, SparkScalar s);
SPARKAPI SparkScalar SPARKCALL SparkVec4Dot(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkScalar SPARKCALL SparkVec4Length(SparkVec4 a);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Normalize(SparkVec4 a);
SPARKAPI SparkScalar SPARKCALL SparkVec4Distance(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Negate(SparkVec4 a);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Lerp(SparkVec4 a, SparkVec4 b, SparkScalar t);

SPARKAPI SparkMat2 SPARKCALL SparkMat2Add(SparkMat2 a, SparkMat2 b);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Subtract(SparkMat2 a, SparkMat2 b);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Multiply(SparkMat2 a, SparkMat2 b);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Scale(SparkMat2 a, SparkScalar s);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Transpose(SparkMat2 m);
SPARKAPI SparkScalar SPARKCALL SparkMat2Determinant(SparkMat2 m);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Inverse(SparkMat2 m);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Identity();

SPARKAPI SparkMat3 SPARKCALL SparkMat3Add(SparkMat3 a, SparkMat3 b);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Subtract(SparkMat3 a, SparkMat3 b);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Multiply(SparkMat3 a, SparkMat3 b);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Scale(SparkMat3 a, SparkScalar s);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Transpose(SparkMat3 m);
SPARKAPI SparkScalar SPARKCALL SparkMat3Determinant(SparkMat3 m);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Inverse(SparkMat3 m);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Identity();

SPARKAPI SparkMat4 SPARKCALL SparkMat4Add(SparkMat4 a, SparkMat4 b);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Subtract(SparkMat4 a, SparkMat4 b);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Multiply(SparkMat4 a, SparkMat4 b);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Scale(SparkMat4 a, SparkScalar s);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Transpose(SparkMat4 m);
SPARKAPI SparkScalar SPARKCALL SparkMat4Determinant(SparkMat4 m);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Inverse(SparkMat4 m);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Identity();
SPARKAPI SparkMat4 SPARKCALL SparkMat4Translate(SparkVec3 translation);
SPARKAPI SparkMat4 SPARKCALL SparkMat4ScaleVec3(SparkVec3 scale);
SPARKAPI SparkMat4 SPARKCALL SparkMat4ScaleScalar(SparkScalar scale);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Rotate(SparkScalar angle, SparkVec3 axis);
SPARKAPI SparkMat4 SPARKCALL SparkMat4RotateX(SparkScalar angle);
SPARKAPI SparkMat4 SPARKCALL SparkMat4RotateY(SparkScalar angle);
SPARKAPI SparkMat4 SPARKCALL SparkMat4RotateZ(SparkScalar angle);
SPARKAPI SparkMat4 SPARKCALL SparkMat4LookAt(SparkVec3 eye, SparkVec3 center,
	SparkVec3 up);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Perspective(SparkScalar fovy, SparkScalar aspect,
	SparkScalar near, SparkScalar far);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Ortho(SparkScalar left, SparkScalar right,
	SparkScalar bottom, SparkScalar top,
	SparkScalar near, SparkScalar far);

SPARKAPI SparkVec3 SPARKCALL SparkVec3Transform(SparkVec3 v, SparkMat4 m);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Transform(SparkVec4 v, SparkMat4 m);

SPARKAPI SparkQuat SPARKCALL SparkQuatMultiply(SparkQuat a, SparkQuat b);
SPARKAPI SparkQuat SPARKCALL SparkQuatConjugate(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatInverse(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatNormalize(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatFromAxisAngle(SparkVec3 axis, SparkScalar angle);
SPARKAPI SparkVoid SPARKCALL SparkQuatToAxisAngle(SparkQuat q, SparkVec3* axis,
	SparkScalar* angle);
SPARKAPI SparkMat4 SPARKCALL SparkQuatToMat4(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatSlerp(SparkQuat a, SparkQuat b, SparkScalar t);

SPARKAPI SparkScalar SPARKCALL SparkRadians(SparkScalar degrees);
SPARKAPI SparkScalar SPARKCALL SparkDegrees(SparkScalar radians);

SPARKAPI SparkScalar SPARKCALL SparkSin(SparkScalar angle);
SPARKAPI SparkScalar SPARKCALL SparkCos(SparkScalar angle);
SPARKAPI SparkScalar SPARKCALL SparkTan(SparkScalar angle);
SPARKAPI SparkScalar SPARKCALL SparkASin(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkACos(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkATan(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkATan2(SparkScalar y, SparkScalar x);

SPARKAPI SparkScalar SPARKCALL SparkSqrt(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkPow(SparkScalar base, SparkScalar exponent);
SPARKAPI SparkScalar SPARKCALL SparkExp(SparkScalar exponent);
SPARKAPI SparkScalar SPARKCALL SparkLogs(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkAbs(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkFloor(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkCeil(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkMix(SparkScalar a, SparkScalar b, SparkScalar t);

/* General math function declarations */

SPARKAPI SparkScalar SPARKCALL SparkMinS(SparkScalar a, SparkScalar b);
SPARKAPI SparkScalar SPARKCALL SparkMaxS(SparkScalar a, SparkScalar b);
SPARKAPI SparkScalar SPARKCALL SparkClampS(SparkScalar x, SparkScalar min_val,
	SparkScalar max_val);
SPARKAPI SparkScalar SPARKCALL SparkMixS(SparkScalar x, SparkScalar y, SparkScalar t);
SPARKAPI SparkScalar SPARKCALL SparkStepS(SparkScalar edge, SparkScalar x);
SPARKAPI SparkScalar SPARKCALL SparkSmoothStepS(SparkScalar edge0, SparkScalar edge1,
	SparkScalar x);
SPARKAPI SparkScalar SPARKCALL SparkSign(SparkScalar x);
SPARKAPI SparkScalar SPARKCALL SparkMod(SparkScalar x, SparkScalar y);

/* Vector and matrix type conversion functions */

SPARKAPI SparkVec3 SPARKCALL SparkVec2ToVec3(SparkVec2 v, SparkScalar z);
SPARKAPI SparkVec4 SPARKCALL SparkVec3ToVec4(SparkVec3 v, SparkScalar w);
SPARKAPI SparkVec2 SPARKCALL SparkVec3ToVec2(SparkVec3 v);
SPARKAPI SparkVec3 SPARKCALL SparkVec4ToVec3(SparkVec4 v);

/* Functions between different vector and matrix types */

SPARKAPI SparkVec2 SPARKCALL SparkMat2MultiplyVec2(SparkMat2 m, SparkVec2 v);
SPARKAPI SparkVec3 SPARKCALL SparkMat3MultiplyVec3(SparkMat3 m, SparkVec3 v);
SPARKAPI SparkVec4 SPARKCALL SparkMat4MultiplyVec4(SparkMat4 m, SparkVec4 v);
SPARKAPI SparkVec3 SPARKCALL SparkMat4MultiplyVec3(SparkMat4 m, SparkVec3 v);

/* Updated math function declarations */

SPARKAPI SparkVec2 SPARKCALL SparkVec2Add(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Subtract(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Multiply(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Divide(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Scale(SparkVec2 a, SparkScalar s);
SPARKAPI SparkScalar SPARKCALL SparkVec2Dot(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkScalar SPARKCALL SparkVec2Length(SparkVec2 a);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Normalize(SparkVec2 a);
SPARKAPI SparkScalar SPARKCALL SparkVec2Distance(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Negate(SparkVec2 a);
SPARKAPI SparkScalar SPARKCALL SparkVec2Angle(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Reflect(SparkVec2 v, SparkVec2 n);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Lerp(SparkVec2 a, SparkVec2 b, SparkScalar t);

SPARKAPI SparkVec3 SPARKCALL SparkVec3Add(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Subtract(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Multiply(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Divide(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Scale(SparkVec3 a, SparkScalar s);
SPARKAPI SparkScalar SPARKCALL SparkVec3Dot(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Cross(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkScalar SPARKCALL SparkVec3Length(SparkVec3 a);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Normalize(SparkVec3 a);
SPARKAPI SparkScalar SPARKCALL SparkVec3Distance(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Negate(SparkVec3 a);
SPARKAPI SparkScalar SPARKCALL SparkVec3Angle(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Reflect(SparkVec3 v, SparkVec3 n);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Lerp(SparkVec3 a, SparkVec3 b, SparkScalar t);

SPARKAPI SparkVec4 SPARKCALL SparkVec4Add(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Subtract(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Multiply(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Divide(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Scale(SparkVec4 a, SparkScalar s);
SPARKAPI SparkScalar SPARKCALL SparkVec4Dot(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkScalar SPARKCALL SparkVec4Length(SparkVec4 a);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Normalize(SparkVec4 a);
SPARKAPI SparkScalar SPARKCALL SparkVec4Distance(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Negate(SparkVec4 a);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Lerp(SparkVec4 a, SparkVec4 b, SparkScalar t);

/* Matrix functions */

SPARKAPI SparkMat2 SPARKCALL SparkMat2Add(SparkMat2 a, SparkMat2 b);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Subtract(SparkMat2 a, SparkMat2 b);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Multiply(SparkMat2 a, SparkMat2 b);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Scale(SparkMat2 m, SparkScalar s);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Transpose(SparkMat2 m);
SPARKAPI SparkScalar SPARKCALL SparkMat2Determinant(SparkMat2 m);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Inverse(SparkMat2 m);
SPARKAPI SparkMat2 SPARKCALL SparkMat2Identity();

SPARKAPI SparkMat3 SPARKCALL SparkMat3Add(SparkMat3 a, SparkMat3 b);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Subtract(SparkMat3 a, SparkMat3 b);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Multiply(SparkMat3 a, SparkMat3 b);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Scale(SparkMat3 m, SparkScalar s);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Transpose(SparkMat3 m);
SPARKAPI SparkScalar SPARKCALL SparkMat3Determinant(SparkMat3 m);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Inverse(SparkMat3 m);
SPARKAPI SparkMat3 SPARKCALL SparkMat3Identity();

SPARKAPI SparkMat4 SPARKCALL SparkMat4Add(SparkMat4 a, SparkMat4 b);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Subtract(SparkMat4 a, SparkMat4 b);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Multiply(SparkMat4 a, SparkMat4 b);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Scale(SparkMat4 m, SparkScalar s);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Transpose(SparkMat4 m);
SPARKAPI SparkScalar SPARKCALL SparkMat4Determinant(SparkMat4 m);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Inverse(SparkMat4 m);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Identity();
SPARKAPI SparkMat4 SPARKCALL SparkMat4Translate(SparkVec3 translation);
SPARKAPI SparkMat4 SPARKCALL SparkMat4ScaleVec3(SparkVec3 scale);
SPARKAPI SparkMat4 SPARKCALL SparkMat4ScaleScalar(SparkScalar scale);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Rotate(SparkScalar angle, SparkVec3 axis);
SPARKAPI SparkMat4 SPARKCALL SparkMat4RotateX(SparkScalar angle);
SPARKAPI SparkMat4 SPARKCALL SparkMat4RotateY(SparkScalar angle);
SPARKAPI SparkMat4 SPARKCALL SparkMat4RotateZ(SparkScalar angle);
SPARKAPI SparkMat4 SPARKCALL SparkMat4LookAt(SparkVec3 eye, SparkVec3 center,
	SparkVec3 up);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Perspective(SparkScalar fovy, SparkScalar aspect,
	SparkScalar near, SparkScalar far);
SPARKAPI SparkMat4 SPARKCALL SparkMat4Ortho(SparkScalar left, SparkScalar right,
	SparkScalar bottom, SparkScalar top,
	SparkScalar near, SparkScalar far);

/* Quaternion functions */

SPARKAPI SparkQuat SPARKCALL SparkQuatMultiply(SparkQuat a, SparkQuat b);
SPARKAPI SparkQuat SPARKCALL SparkQuatConjugate(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatInverse(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatNormalize(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatFromAxisAngle(SparkVec3 axis, SparkScalar angle);
SPARKAPI SparkVoid SPARKCALL SparkQuatToAxisAngle(SparkQuat q, SparkVec3* axis,
	SparkScalar* angle);
SPARKAPI SparkMat4 SPARKCALL SparkQuatToMat4(SparkQuat q);
SPARKAPI SparkQuat SPARKCALL SparkQuatSlerp(SparkQuat a, SparkQuat b, SparkScalar t);

/* Trigonometric functions */

SPARKAPI SparkScalar SPARKCALL SparkRadians(SparkScalar degrees);
SPARKAPI SparkScalar SPARKCALL SparkDegrees(SparkScalar radians);

SPARKAPI SparkScalar SPARKCALL SparkSin(SparkScalar angle);
SPARKAPI SparkScalar SPARKCALL SparkCos(SparkScalar angle);
SPARKAPI SparkScalar SPARKCALL SparkTan(SparkScalar angle);
SPARKAPI SparkScalar SPARKCALL SparkASin(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkACos(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkATan(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkATan2(SparkScalar y, SparkScalar x);

/* Exponential and logarithmic functions */

SPARKAPI SparkScalar SPARKCALL SparkExp(SparkScalar exponent);
SPARKAPI SparkScalar SPARKCALL SparkLog2(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkPow(SparkScalar base, SparkScalar exponent);
SPARKAPI SparkScalar SPARKCALL SparkSqrt(SparkScalar value);
SPARKAPI SparkScalar SPARKCALL SparkInverseSqrt(SparkScalar value);

/* Functions operating on vectors */

SPARKAPI SparkVec3 SPARKCALL SparkCross(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkScalar SPARKCALL SparkDistance(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkScalar SPARKCALL SparkLength(SparkVec3 v);
SPARKAPI SparkVec3 SPARKCALL SparkNormalize(SparkVec3 v);
SPARKAPI SparkScalar SPARKCALL SparkDot(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkReflect(SparkVec3 v, SparkVec3 n);
SPARKAPI SparkVec3 SPARKCALL SparkRefract(SparkVec3 v, SparkVec3 n, SparkScalar eta);

/* Component-wise vector operations */

SPARKAPI SparkVec2 SPARKCALL SparkVec2Min(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Max(SparkVec2 a, SparkVec2 b);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Clamp(SparkVec2 v, SparkVec2 min_val,
	SparkVec2 max_val);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Mix(SparkVec2 a, SparkVec2 b, SparkScalar t);
SPARKAPI SparkVec2 SPARKCALL SparkVec2Step(SparkVec2 edge, SparkVec2 x);
SPARKAPI SparkVec2 SPARKCALL SparkVec2SmoothStep(SparkVec2 edge0, SparkVec2 edge1,
	SparkVec2 x);

SPARKAPI SparkVec3 SPARKCALL SparkVec3Min(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Max(SparkVec3 a, SparkVec3 b);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Clamp(SparkVec3 v, SparkVec3 min_val,
	SparkVec3 max_val);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Mix(SparkVec3 a, SparkVec3 b, SparkScalar t);
SPARKAPI SparkVec3 SPARKCALL SparkVec3Step(SparkVec3 edge, SparkVec3 x);
SPARKAPI SparkVec3 SPARKCALL SparkVec3SmoothStep(SparkVec3 edge0, SparkVec3 edge1,
	SparkVec3 x);

SPARKAPI SparkVec4 SPARKCALL SparkVec4Min(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Max(SparkVec4 a, SparkVec4 b);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Clamp(SparkVec4 v, SparkVec4 min_val,
	SparkVec4 max_val);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Mix(SparkVec4 a, SparkVec4 b, SparkScalar t);
SPARKAPI SparkVec4 SPARKCALL SparkVec4Step(SparkVec4 edge, SparkVec4 x);
SPARKAPI SparkVec4 SPARKCALL SparkVec4SmoothStep(SparkVec4 edge0, SparkVec4 edge1,
	SparkVec4 x);

/* Vector addition */
#define SparkVecAdd(a, b)                                                      \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Add,                                                 \
      SparkVec3: SparkVec3Add,                                                 \
      SparkVec4: SparkVec4Add)(a, b)

/* Vector subtraction */
#define SparkVecSubtract(a, b)                                                 \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Subtract,                                            \
      SparkVec3: SparkVec3Subtract,                                            \
      SparkVec4: SparkVec4Subtract)(a, b)

/* Vector multiplication */
#define SparkVecMultiply(a, b)                                                 \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Multiply,                                            \
      SparkVec3: SparkVec3Multiply,                                            \
      SparkVec4: SparkVec4Multiply)(a, b)

/* Vector division */
#define SparkVecDivide(a, b)                                                   \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Divide,                                              \
      SparkVec3: SparkVec3Divide,                                              \
      SparkVec4: SparkVec4Divide)(a, b)

/* Vector scaling */
#define SparkVecScale(a, s)                                                    \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Scale,                                               \
      SparkVec3: SparkVec3Scale,                                               \
      SparkVec4: SparkVec4Scale)(a, s)

/* Vector dot product */
#define SparkVecDot(a, b)                                                      \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Dot,                                                 \
      SparkVec3: SparkVec3Dot,                                                 \
      SparkVec4: SparkVec4Dot)(a, b)

/* Vector length */
#define SparkVecLength(a)                                                      \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Length,                                              \
      SparkVec3: SparkVec3Length,                                              \
      SparkVec4: SparkVec4Length)(a)

/* Vector normalization */
#define SparkVecNormalize(a)                                                   \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Normalize,                                           \
      SparkVec3: SparkVec3Normalize,                                           \
      SparkVec4: SparkVec4Normalize)(a)

/* Vector distance */
#define SparkVecDistance(a, b)                                                 \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Distance,                                            \
      SparkVec3: SparkVec3Distance,                                            \
      SparkVec4: SparkVec4Distance)(a, b)

/* Vector negation */
#define SparkVecNegate(a)                                                      \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Negate,                                              \
      SparkVec3: SparkVec3Negate,                                              \
      SparkVec4: SparkVec4Negate)(a)

/* Vector angle (only for Vec2 and Vec3) */
#define SparkVecAngle(a, b)                                                    \
  _Generic((a), SparkVec2: SparkVec2Angle, SparkVec3: SparkVec3Angle)(a, b)

/* Vector reflection */
#define SparkVecReflect(v, n)                                                  \
  _Generic((v), SparkVec2: SparkVec2Reflect, SparkVec3: SparkVec3Reflect)(v, n)

/* Vector linear interpolation */
#define SparkVecLerp(a, b, t)                                                  \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Lerp,                                                \
      SparkVec3: SparkVec3Lerp,                                                \
      SparkVec4: SparkVec4Lerp)(a, b, t)

/* Vector cross product (only for Vec3) */
#define SparkVecCross(a, b) _Generic((a), SparkVec3: SparkVec3Cross)(a, b)

/* Matrix addition */
#define SparkMatAdd(a, b)                                                      \
  _Generic((a),                                                                \
      SparkMat2: SparkMat2Add,                                                 \
      SparkMat3: SparkMat3Add,                                                 \
      SparkMat4: SparkMat4Add)(a, b)

/* Matrix subtraction */
#define SparkMatSubtract(a, b)                                                 \
  _Generic((a),                                                                \
      SparkMat2: SparkMat2Subtract,                                            \
      SparkMat3: SparkMat3Subtract,                                            \
      SparkMat4: SparkMat4Subtract)(a, b)

/* Matrix multiplication */
#define SparkMatMultiply(a, b)                                                 \
  _Generic((a),                                                                \
      SparkMat2: SparkMat2Multiply,                                            \
      SparkMat3: SparkMat3Multiply,                                            \
      SparkMat4: SparkMat4Multiply)(a, b)

/* Matrix scaling */
#define SparkMatScale(a, s)                                                    \
  _Generic((a),                                                                \
      SparkMat2: SparkMat2Scale,                                               \
      SparkMat3: SparkMat3Scale,                                               \
      SparkMat4: SparkMat4Scale)(a, s)

/* Matrix transpose */
#define SparkMatTranspose(a)                                                   \
  _Generic((a),                                                                \
      SparkMat2: SparkMat2Transpose,                                           \
      SparkMat3: SparkMat3Transpose,                                           \
      SparkMat4: SparkMat4Transpose)(a)

/* Matrix determinant */
#define SparkMatDeterminant(a)                                                 \
  _Generic((a),                                                                \
      SparkMat2: SparkMat2Determinant,                                         \
      SparkMat3: SparkMat3Determinant,                                         \
      SparkMat4: SparkMat4Determinant)(a)

/* Matrix inverse */
#define SparkMatInverse(a)                                                     \
  _Generic((a),                                                                \
      SparkMat2: SparkMat2Inverse,                                             \
      SparkMat3: SparkMat3Inverse,                                             \
      SparkMat4: SparkMat4Inverse)(a)

/* Matrix identity (note: requires specifying the type) */
#define SparkMatIdentity(type)                                                 \
  _Generic(*(type *)0,                                                         \
      SparkMat2: SparkMat2Identity,                                            \
      SparkMat3: SparkMat3Identity,                                            \
      SparkMat4: SparkMat4Identity)()

/* Scalar and vector min function */
#define SparkMin(a, b)                                                         \
  _Generic((a),                                                                \
      SparkScalar: SparkMin,                                                   \
      SparkVec2: SparkVec2Min,                                                 \
      SparkVec3: SparkVec3Min,                                                 \
      SparkVec4: SparkVec4Min)(a, b)

/* Scalar and vector max function */
#define SparkMax(a, b)                                                         \
  _Generic((a),                                                                \
      SparkScalar: SparkMax,                                                   \
      SparkVec2: SparkVec2Max,                                                 \
      SparkVec3: SparkVec3Max,                                                 \
      SparkVec4: SparkVec4Max)(a, b)

/* Scalar and vector clamp function */
#define SparkClamp(x, min_val, max_val)                                        \
  _Generic((x),                                                                \
      SparkScalar: SparkClampS,                                                \
      SparkVec2: SparkVec2Clamp,                                               \
      SparkVec3: SparkVec3Clamp,                                               \
      SparkVec4: SparkVec4Clamp)(x, min_val, max_val)

/* Scalar and vector mix (linear interpolation) function */
#define SparkMix(a, b, t)                                                      \
  _Generic((a),                                                                \
      SparkScalar: SparkMix,                                                   \
      SparkVec2: SparkVec2Mix,                                                 \
      SparkVec3: SparkVec3Mix,                                                 \
      SparkVec4: SparkVec4Mix)(a, b, t)

/* Scalar and vector step function */
#define SparkStep(edge, x)                                                     \
  _Generic((x),                                                                \
      SparkScalar: SparkStep,                                                  \
      SparkVec2: SparkVec2Step,                                                \
      SparkVec3: SparkVec3Step,                                                \
      SparkVec4: SparkVec4Step)(edge, x)

/* Scalar and vector smoothstep function */
#define SparkSmoothStep(edge0, edge1, x)                                       \
  _Generic((x),                                                                \
      SparkScalar: SparkSmoothStep,                                            \
      SparkVec2: SparkVec2SmoothStep,                                          \
      SparkVec3: SparkVec3SmoothStep,                                          \
      SparkVec4: SparkVec4SmoothStep)(edge0, edge1, x)

/* Matrix-vector multiplication */
#define SparkMatMultiplyVec(m, v)                                              \
  _Generic((m),                                                                \
      SparkMat2: SparkMat2MultiplyVec2,                                        \
      SparkMat3: SparkMat3MultiplyVec3,                                        \
      SparkMat4: _Generic((v),                                                 \
      SparkVec3: SparkMat4MultiplyVec3,                                        \
      SparkVec4: SparkMat4MultiplyVec4))(m, v)

/* General vector functions */
#define SparkLength(v)                                                         \
  _Generic((v),                                                                \
      SparkVec2: SparkVec2Length,                                              \
      SparkVec3: SparkVec3Length,                                              \
      SparkVec4: SparkVec4Length)(v)

#define SparkNormalize(v)                                                      \
  _Generic((v),                                                                \
      SparkVec2: SparkVec2Normalize,                                           \
      SparkVec3: SparkVec3Normalize,                                           \
      SparkVec4: SparkVec4Normalize)(v)

#define SparkDot(a, b)                                                         \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Dot,                                                 \
      SparkVec3: SparkVec3Dot,                                                 \
      SparkVec4: SparkVec4Dot)(a, b)

#define SparkDistance(a, b)                                                    \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Distance,                                            \
      SparkVec3: SparkVec3Distance,                                            \
      SparkVec4: SparkVec4Distance)(a, b)

/* Cross product for SparkVec3 */
#define SparkCross(a, b) _Generic((a), SparkVec3: SparkVec3Cross)(a, b)

/* Reflect function for vectors */
#define SparkReflect(v, n)                                                     \
  _Generic((v), SparkVec2: SparkVec2Reflect, SparkVec3: SparkVec3Reflect)(v, n)

/* Component-wise vector min function */
#define SparkVecMin(a, b)                                                      \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Min,                                                 \
      SparkVec3: SparkVec3Min,                                                 \
      SparkVec4: SparkVec4Min)(a, b)

/* Component-wise vector max function */
#define SparkVecMax(a, b)                                                      \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Max,                                                 \
      SparkVec3: SparkVec3Max,                                                 \
      SparkVec4: SparkVec4Max)(a, b)

/* Component-wise vector clamp function */
#define SparkVecClamp(v, min_val, max_val)                                     \
  _Generic((v),                                                                \
      SparkVec2: SparkVec2Clamp,                                               \
      SparkVec3: SparkVec3Clamp,                                               \
      SparkVec4: SparkVec4Clamp)(v, min_val, max_val)

/* Component-wise vector mix function */
#define SparkVecMix(a, b, t)                                                   \
  _Generic((a),                                                                \
      SparkVec2: SparkVec2Mix,                                                 \
      SparkVec3: SparkVec3Mix,                                                 \
      SparkVec4: SparkVec4Mix)(a, b, t)

/* Component-wise vector step function */
#define SparkVecStep(edge, x)                                                  \
  _Generic((x),                                                                \
      SparkVec2: SparkVec2Step,                                                \
      SparkVec3: SparkVec3Step,                                                \
      SparkVec4: SparkVec4Step)(edge, x)

/* Component-wise vector smoothstep function */
#define SparkVecSmoothStep(edge0, edge1, x)                                    \
  _Generic((x),                                                                \
      SparkVec2: SparkVec2SmoothStep,                                          \
      SparkVec3: SparkVec3SmoothStep,                                          \
      SparkVec4: SparkVec4SmoothStep)(edge0, edge1, x)

#pragma endregion


/* Returns either a success or failure depending on the error code */
SPARKAPI SparkResult SPARKCALL SparkCheckSuccess(SparkResult result);

/* Hash functions */

SPARKAPI SparkSize SPARKCALL DJB2Hash(SparkConstBuffer buf, SparkSize size);
SPARKAPI SparkSize SPARKCALL FNV1AHash(SparkConstBuffer buf, SparkSize size);
SPARKAPI SparkSize SPARKCALL JenkinsHash(SparkConstBuffer buf, SparkSize size);
SPARKAPI SparkSize SPARKCALL Murmur2Hash(SparkConstBuffer buf, SparkSize size);
SPARKAPI SparkSize SPARKCALL SipHash(SparkConstBuffer buf, SparkSize size);
SPARKAPI SparkSize SPARKCALL XXHash(SparkConstBuffer buf, SparkSize size);
SPARKAPI SparkSize SPARKCALL SparkStringHash(SparkConstBuffer key, SparkSize key_size);
SPARKAPI SparkSize SPARKCALL SparkIntegerHash(SparkConstBuffer key, SparkSize key_size);
SPARKAPI SparkI32 SPARKCALL SparkStringCompare(SparkConstBuffer a, SparkSize a_size,
	SparkConstBuffer b, SparkSize b_size);
SPARKAPI SparkI32 SPARKCALL SparkIntegerCompare(SparkConstBuffer a, SparkSize a_size,
	SparkConstBuffer b, SparkSize b_size);

SPARKAPI SparkHandle SPARKCALL SparkAllocate(SparkSize size);
SPARKAPI SparkHandle SPARKCALL SparkReallocate(SparkHandle handle, SparkSize size);
SPARKAPI SparkVoid SPARKCALL SparkFree(SparkHandle handle);
SPARKAPI SparkAllocator SPARKCALL SparkDefaultAllocator();
SPARKAPI SparkAllocator SPARKCALL SparkCreateAllocator(SparkAllocateFunction allocate,
	SparkReallocateFunction reallocate,
	SparkFreeFunction free);
SPARKAPI SparkVoid SPARKCALL SparkDestroyAllocator(SparkAllocator allocator);

SPARKAPI SparkVector SPARKCALL SparkDefaultVector();
SPARKAPI SparkVector SPARKCALL SparkCreateVector(SparkSize capacity,
	SparkAllocator allocator,
	SparkFreeFunction destructor);
SPARKAPI SparkVoid SPARKCALL SparkDestroyVector(SparkVector vector);
SPARKAPI SparkHandle SPARKCALL SparkGetElementVector(SparkVector vector,
	SparkIndex index);
SPARKAPI SparkResult SPARKCALL SparkPushBackVector(SparkVector vector,
	SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkPopBackVector(SparkVector vector);
SPARKAPI SparkResult SPARKCALL SparkInsertVector(SparkVector vector, SparkIndex index,
	SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkRemoveVector(SparkVector vector, SparkIndex index);
SPARKAPI SparkResult SPARKCALL SparkEraseVector(SparkVector vector, SparkIndex start,
	SparkIndex end);
SPARKAPI SparkResult SPARKCALL SparkSetVector(SparkVector vector, SparkIndex index,
	SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkResizeVector(SparkVector vector, SparkSize capacity);
SPARKAPI SparkResult SPARKCALL SparkClearVector(SparkVector vector);

SPARKAPI SparkList SPARKCALL SparkDefaultList();
SPARKAPI SparkList SPARKCALL SparkCreateList(SparkAllocator allocator,
	SparkFreeFunction destructor);
SPARKAPI SparkVoid SPARKCALL SparkDestroyList(SparkList list);
SPARKAPI SparkHandle SPARKCALL SparkGetElementList(SparkList list, SparkIndex index);
SPARKAPI SparkResult SPARKCALL SparkPushBackList(SparkList list, SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkPopBackList(SparkList list, SparkBuffer element);
SPARKAPI SparkResult SPARKCALL SparkInsertList(SparkList list, SparkIndex index,
	SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkRemoveList(SparkList list, SparkIndex index);
SPARKAPI SparkResult SPARKCALL SparkSetList(SparkList list, SparkIndex index,
	SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkClearList(SparkList list);

SPARKAPI SparkMap SPARKCALL SparkDefaultMap();
SPARKAPI SparkMap SPARKCALL SparkCreateMap(SparkAllocator allocator);
SPARKAPI SparkVoid SPARKCALL SparkDestroyMap(SparkMap map);
SPARKAPI SparkHandle SPARKCALL SparkGetElementMap(SparkMap map, SparkConstBuffer key);
SPARKAPI SparkResult SPARKCALL SparkInsertMap(SparkMap map, SparkConstBuffer key,
	SparkConstBuffer value);
SPARKAPI SparkResult SPARKCALL SparkRemoveMap(SparkMap map, SparkConstBuffer key);
SPARKAPI SparkResult SPARKCALL SparkSetMap(SparkMap map, SparkConstBuffer key,
	SparkConstBuffer value);
SPARKAPI SparkResult SPARKCALL SparkClearMap(SparkMap map);

SPARKAPI SparkHashMap SPARKCALL SparkDefaultHashMap();
SPARKAPI SparkHashMap SPARKCALL SparkCreateHashMap(SparkSize capacity,
	SparkHashFunction hash_function,
	SparkCompareFunction compare_function,
	SparkAllocator allocator,
	SparkFreeFunction key_destructor,
	SparkFreeFunction value_destructor);
SPARKAPI SparkVoid SPARKCALL SparkDestroyHashMap(SparkHashMap hashmap);
SPARKAPI SparkResult SPARKCALL SparkInsertHashMap(SparkHashMap hashmap, SparkHandle key,
	SparkSize key_size, SparkHandle value);
SPARKAPI SparkHandle SPARKCALL SparkGetElementHashMap(SparkHashMap hashmap,
	SparkHandle key,
	SparkSize key_size);
SPARKAPI SparkBool SPARKCALL SparkContainsHashMap(SparkHashMap hashmap, SparkHandle key,
	SparkSize key_size);
SPARKAPI SparkResult SPARKCALL SparkRemoveHashMap(SparkHashMap hashmap, SparkHandle key,
	SparkSize key_size);
SPARKAPI SparkVector SPARKCALL SparkGetAllKeysHashMap(SparkHashMap hashmap);
SPARKAPI SparkVector SPARKCALL SparkGetAllValuesHashMap(SparkHashMap hashmap);

SPARKAPI SparkSet SPARKCALL SparkDefaultSet();
SPARKAPI SparkSet SPARKCALL SparkCreateSet(SparkSize capacity, SparkAllocator allocator,
	SparkFreeFunction destructor);
SPARKAPI SparkVoid SPARKCALL SparkDestroySet(SparkSet set);
SPARKAPI SparkHandle SPARKCALL SparkGetElementSet(SparkSet set, SparkSize index);
SPARKAPI SparkBool SPARKCALL SparkContainsSet(SparkSet set, SparkHandle element,
	SparkCompareFunction compare);
SPARKAPI SparkResult SPARKCALL SparkInsertSet(SparkSet set, SparkHandle element,
	SparkCompareFunction compare);
SPARKAPI SparkResult SPARKCALL SparkRemoveSet(SparkSet set, SparkHandle element,
	SparkCompareFunction compare);
SPARKAPI SparkResult SPARKCALL SparkClearSet(SparkSet set);

SPARKAPI SparkHashSet SPARKCALL SparkDefaultHashSet();
SPARKAPI SparkHashSet SPARKCALL SparkCreateHashSet(SparkSize capacity,
	SparkSize element_size,
	SparkHashFunction hash,
	SparkAllocator allocator,
	SparkFreeFunction destructor);
SPARKAPI SparkVoid SPARKCALL SparkDestroyHashSet(SparkHashSet hashset);
SPARKAPI SparkBool SPARKCALL SparkContainsHashSet(SparkHashSet hashset,
	SparkHandle element,
	SparkSize element_size);
SPARKAPI SparkResult SPARKCALL SparkInsertHashSet(SparkHashSet hashset,
	SparkHandle element,
	SparkSize element_size);
SPARKAPI SparkResult SPARKCALL SparkRemoveHashSet(SparkHashSet hashset,
	SparkHandle element,
	SparkSize element_size);
SPARKAPI SparkResult SPARKCALL SparkClearHashSet(SparkHashSet hashset);

SPARKAPI SparkQueue SPARKCALL SparkDefaultQueue();
SPARKAPI SparkQueue SPARKCALL SparkCreateQueue(SparkSize capacity,
	SparkAllocator allocator,
	SparkFreeFunction destructor);
SPARKAPI SparkVoid SPARKCALL SparkDestroyQueue(SparkQueue queue);
SPARKAPI SparkResult SPARKCALL SparkEnqueueQueue(SparkQueue queue, SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkDequeueQueue(SparkQueue queue);
SPARKAPI SparkHandle SPARKCALL SparkGetFrontQueue(SparkQueue queue);
SPARKAPI SparkHandle SPARKCALL SparkGetBackQueue(SparkQueue queue);
SPARKAPI SparkResult SPARKCALL SparkClearQueue(SparkQueue queue);

SPARKAPI SparkStack SPARKCALL SparkDefaultStack();
SPARKAPI SparkStack SPARKCALL SparkCreateStack(SparkSize capacity,
	SparkAllocator allocator,
	SparkFreeFunction destructor);
SPARKAPI SparkVoid SPARKCALL SparkDestroyStack(SparkStack stack);
SPARKAPI SparkResult SPARKCALL SparkPushStack(SparkStack stack, SparkHandle element);
SPARKAPI SparkResult SPARKCALL SparkPopStack(SparkStack stack);
SPARKAPI SparkHandle SPARKCALL SparkGetTopStack(SparkStack stack);
SPARKAPI SparkResult SPARKCALL SparkClearStack(SparkStack stack);

/* Shader-related function declarations */

typedef struct SparkShaderT* SparkShader;
typedef struct SparkProgramT* SparkProgram;

/* Shader creation and deletion */
SPARKAPI SparkShader SPARKCALL SparkCreateShader(SparkShaderType type,
	SparkConstString source);
SPARKAPI SparkResult SPARKCALL SparkCompileShader(SparkShader shader);
SPARKAPI SparkVoid SPARKCALL SparkDeleteShader(SparkShader shader);

/* Program creation, linking, and deletion */
SPARKAPI SparkProgram SPARKCALL SparkCreateProgram();
SPARKAPI SparkResult SPARKCALL SparkAttachShader(SparkProgram program,
	SparkShader shader);
SPARKAPI SparkResult SPARKCALL SparkLinkProgram(SparkProgram program);
SPARKAPI SparkVoid SPARKCALL SparkDeleteProgram(SparkProgram program);

/* Using the shader program */
SPARKAPI SparkResult SPARKCALL SparkUseProgram(SparkProgram program);

/* Uniform setting functions */
SPARKAPI SparkResult SPARKCALL SparkSetUniform1f(SparkProgram program,
	SparkConstString name, SparkF32 v0);
SPARKAPI SparkResult SPARKCALL SparkSetUniform2f(SparkProgram program,
	SparkConstString name, SparkF32 v0,
	SparkF32 v1);
SPARKAPI SparkResult SPARKCALL SparkSetUniform3f(SparkProgram program,
	SparkConstString name, SparkF32 v0,
	SparkF32 v1, SparkF32 v2);
SPARKAPI SparkResult SPARKCALL SparkSetUniform4f(SparkProgram program,
	SparkConstString name, SparkF32 v0,
	SparkF32 v1, SparkF32 v2, SparkF32 v3);

SPARKAPI SparkResult SPARKCALL SparkSetUniform1i(SparkProgram program,
	SparkConstString name, SparkI32 v0);
SPARKAPI SparkResult SPARKCALL SparkSetUniform2i(SparkProgram program,
	SparkConstString name, SparkI32 v0,
	SparkI32 v1);
SPARKAPI SparkResult SPARKCALL SparkSetUniform3i(SparkProgram program,
	SparkConstString name, SparkI32 v0,
	SparkI32 v1, SparkI32 v2);
SPARKAPI SparkResult SPARKCALL SparkSetUniform4i(SparkProgram program,
	SparkConstString name, SparkI32 v0,
	SparkI32 v1, SparkI32 v2, SparkI32 v3);

/* Uniform setting functions for matrices */
SPARKAPI SparkResult SPARKCALL SparkSetUniformMat2(SparkProgram program,
	SparkConstString name, SparkMat2 mat);
SPARKAPI SparkResult SPARKCALL SparkSetUniformMat3(SparkProgram program,
	SparkConstString name, SparkMat3 mat);
SPARKAPI SparkResult SPARKCALL SparkSetUniformMat4(SparkProgram program,
	SparkConstString name, SparkMat4 mat);

/* Attribute location functions */
SPARKAPI SparkResult SPARKCALL SparkBindAttribLocation(SparkProgram program,
	SparkIndex index,
	SparkConstString name);
SPARKAPI SparkResult SPARKCALL SparkGetAttribLocation(SparkProgram program,
	SparkConstString name,
	SparkIndex* location);

/* Error handling */
SPARKAPI SparkConstString SPARKCALL SparkGetShaderLog(SparkShader shader);
SPARKAPI SparkConstString SPARKCALL SparkGetProgramLog(SparkProgram program);

/* Shader reflection functions */
SPARKAPI SparkResult SPARKCALL SparkGetUniformLocation(SparkProgram program,
	SparkConstString name,
	SparkIndex* location);

/* Shader utility functions */
SPARKAPI SparkResult SPARKCALL SparkLoadShaderFromFile(SparkShader shader,
	SparkConstString filePath);
SPARKAPI SparkResult SPARKCALL SparkSetShaderSource(SparkShader shader,
	SparkConstString source);

/* Uniform Buffer Object (UBO) functions */
typedef struct SparkUniformBufferT* SparkUniformBuffer;
SPARKAPI SparkUniformBuffer SPARKCALL SparkCreateUniformBuffer(SparkSize size,
	SparkConstBuffer data);
SPARKAPI SparkVoid SPARKCALL SparkDeleteUniformBuffer(SparkUniformBuffer buffer);
SPARKAPI SparkResult SPARKCALL SparkBindUniformBuffer(SparkProgram program,
	SparkConstString name,
	SparkUniformBuffer buffer);

/* Vertex Buffer functions */
typedef struct SparkVertexBufferT* SparkVertexBuffer;
SPARKAPI SparkVertexBuffer SPARKCALL SparkCreateVertexBuffer(SparkSize size,
	SparkConstBuffer data);
SPARKAPI SparkVoid SPARKCALL SparkDeleteVertexBuffer(SparkVertexBuffer buffer);
SPARKAPI SparkResult SPARKCALL SparkBindVertexBuffer(SparkVertexBuffer buffer);
SPARKAPI SparkResult SPARKCALL SparkSetVertexAttribPointer(
	SparkIndex index, SparkI32 size, SparkShaderDataType type,
	SparkBool normalized, SparkSize stride, SparkSize offset);

/* Index Buffer functions */
typedef struct SparkIndexBufferT* SparkIndexBuffer;
SPARKAPI SparkIndexBuffer SPARKCALL SparkCreateIndexBuffer(SparkSize size,
	SparkConstBuffer data);
SPARKAPI SparkVoid SPARKCALL SparkDeleteIndexBuffer(SparkIndexBuffer buffer);
SPARKAPI SparkResult SPARKCALL SparkBindIndexBuffer(SparkIndexBuffer buffer);

/* Drawing functions */
SPARKAPI SparkResult SPARKCALL SparkDrawArrays(SparkPrimitiveType mode, SparkIndex first,
	SparkSize count);
SPARKAPI SparkResult SPARKCALL SparkDrawElements(SparkPrimitiveType mode, SparkSize count,
	SparkShaderDataType type,
	SparkSize offset);

/* Texture functions */
typedef struct SparkTextureT* SparkTexture;
SPARKAPI SparkTexture SPARKCALL SparkCreateTexture2D(SparkI32 width, SparkI32 height,
	SparkConstBuffer data);
SPARKAPI SparkVoid SPARKCALL SparkDeleteTexture(SparkTexture texture);
SPARKAPI SparkResult SPARKCALL SparkBindTexture(SparkTexture texture, SparkI32 unit);
SPARKAPI SparkResult SPARKCALL SparkSetTextureParameter(SparkTexture texture,
	SparkI32 pname, SparkI32 param);

/* Framebuffer functions */
typedef struct SparkFramebufferT* SparkFramebuffer;
SPARKAPI SparkFramebuffer SPARKCALL SparkCreateFramebuffer();
SPARKAPI SparkVoid SPARKCALL SparkDeleteFramebuffer(SparkFramebuffer framebuffer);
SPARKAPI SparkResult SPARKCALL SparkBindFramebuffer(SparkFramebuffer framebuffer);
SPARKAPI SparkResult SPARKCALL SparkFramebufferTexture2D(SparkFramebuffer framebuffer,
	SparkTexture texture);

/* Renderbuffer functions */
typedef struct SparkRenderbufferT* SparkRenderbuffer;
SPARKAPI SparkRenderbuffer SPARKCALL SparkCreateRenderbuffer(SparkI32 width,
	SparkI32 height);
SPARKAPI SparkVoid SPARKCALL SparkDeleteRenderbuffer(SparkRenderbuffer renderbuffer);
SPARKAPI SparkResult SPARKCALL SparkBindRenderbuffer(SparkRenderbuffer renderbuffer);
SPARKAPI SparkResult SPARKCALL SparkFramebufferRenderbuffer(
	SparkFramebuffer framebuffer, SparkRenderbuffer renderbuffer);

/* Render loop functions */
SPARKAPI SparkResult SPARKCALL SparkClear(SparkU32 mask);
SPARKAPI SparkResult SPARKCALL SparkSetClearColor(SparkF32 red, SparkF32 green,
	SparkF32 blue, SparkF32 alpha);
SPARKAPI SparkResult SPARKCALL SparkSetViewport(SparkI32 x, SparkI32 y, SparkI32 width,
	SparkI32 height);

/* State setting functions */
SPARKAPI SparkResult SPARKCALL SparkEnable(SparkU32 capability);
SPARKAPI SparkResult SPARKCALL SparkDisable(SparkU32 capability);

/* Blend functions */
SPARKAPI SparkResult SPARKCALL SparkBlendFunc(SparkBlendMode sfactor,
	SparkBlendMode dfactor);

SPARKAPI SparkError SPARKCALL SparkGetError();
SPARKAPI SparkConstString SPARKCALL SparkGetErrorString(SparkError error);



SPARKAPI SparkResult SPARKCALL SparkAddRigidBody(SparkEcs ecs, SparkEntity entity, SparkRigidBody rigidBody);
SPARKAPI SparkResult SPARKCALL SparkAddCollider(SparkEcs ecs, SparkEntity entity, SparkCollider collider);

SPARKAPI SparkInput SPARKCALL SparkCreateInput();
SPARKAPI SparkVoid SPARKCALL SparkDestroyInput(SparkInput input);
SPARKAPI SparkVoid SPARKCALL SparkUpdateInput(SparkInput input);


SPARKAPI SparkAudioBuffer SPARKCALL SparkCreateAudioBuffer(SparkConstString filePath);
SPARKAPI SparkVoid SPARKCALL SparkDeleteAudioBuffer(SparkAudioBuffer buffer);
SPARKAPI SparkAudioSource SPARKCALL SparkCreateAudioSource();
SPARKAPI SparkVoid SPARKCALL SparkDeleteAudioSource(SparkAudioSource source);
SPARKAPI SparkVoid SPARKCALL SparkPlayAudioSource(SparkAudioSource source, SparkAudioBuffer buffer);
SPARKAPI SparkVoid SPARKCALL SparkStopAudioSource(SparkAudioSource source);
SPARKAPI SparkVoid SPARKCALL SparkSetAudioSourcePosition(SparkAudioSource source, SparkVec3 position);
SPARKAPI SparkVoid SPARKCALL SparkSetAudioListenerPosition(SparkVec3 position);
SPARKAPI SparkVoid SPARKCALL SparkSetAudioListenerOrientation(SparkVec3 forward, SparkVec3 up);

SPARKAPI SparkFileSerializer SPARKCALL SparkCreateFileSerializer(SparkConstString path);
SPARKAPI SparkVoid SPARKCALL SparkDestroyFileSerializer(SparkFileSerializer serializer);
SPARKAPI SparkResult SPARKCALL SparkSerializeRawData(SparkFileSerializer serializer, SparkHandle data, SparkSize size);
SPARKAPI SparkResult SPARKCALL SparkSerializeData(SparkFileSerializer serializer, SparkHandle data, SparkSize size);
SPARKAPI SparkResult SPARKCALL SparkSerializeHeader(SparkFileSerializer serializer);
SPARKAPI SparkFileDeserializer SPARKCALL SparkCreateFileDeserializer(SparkConstString path);
SPARKAPI SparkVoid SPARKCALL SparkDestroyFileDeserializer(SparkFileDeserializer deserializer);
SPARKAPI SparkResult SPARKCALL SparkDeserializeRawData(SparkFileDeserializer deserializer, SparkHandle data, SparkSize size);
SPARKAPI SparkResult SPARKCALL SparkDeserializeData(SparkFileDeserializer deserializer, SparkHandle* data, SparkSize* size);
SPARKAPI SparkResult SPARKCALL SparkDeserializeRawData(SparkFileDeserializer deserializer, SparkHandle* data, SparkSize size);
SPARKAPI SparkResult SPARKCALL SparkDeserializeHeader(SparkFileDeserializer deserializer);
SPARKAPI SparkResult SPARKCALL SparkDeserializeString(SparkFileDeserializer deserializer, SparkBuffer* data, SparkSize* size);
SPARKAPI SparkResult SPARKCALL SparkDeserializeTrivial(SparkFileDeserializer deserializer, SparkHandle data, SparkSize size);

SPARKAPI SparkScene SPARKCALL SparkCreateScene();
SPARKAPI SparkVoid SPARKCALL SparkDestroyScene(SparkScene scene);
SPARKAPI SparkResult SPARKCALL SparkAddEntityToScene(SparkScene scene, SparkEntity entity, SparkSceneNode parent);
SPARKAPI SparkResult SPARKCALL SparkRemoveEntityFromScene(SparkScene scene, SparkEntity entity);

/* Resource management declarations */
SPARKAPI SparkResource SPARKCALL SparkLoadResource(SparkResourceRegistry registry, SparkConstString type, SparkConstString filePath);
SPARKAPI SparkVoid SPARKCALL SparkUnloadResource(SparkResourceRegistry registry, SparkResource resource);
SPARKAPI SparkResource SPARKCALL SparkGetResource(SparkResourceRegistry registry, SparkConstString name);

SPARKAPI SparkAnimation SPARKCALL SparkCreateAnimation(SparkConstString filePath);
SPARKAPI SparkVoid SPARKCALL SparkDestroyAnimation(SparkAnimation animation);
SPARKAPI SparkResult SPARKCALL SparkPlayAnimation(SparkEntity entity, SparkAnimation animation);

SPARKAPI SparkGuiElement SPARKCALL SparkCreateGuiElement(SparkConstString type);
SPARKAPI SparkVoid SPARKCALL SparkDestroyGuiElement(SparkGuiElement element);
SPARKAPI SparkResult SPARKCALL SparkSetGuiElementProperty(SparkGuiElement element, SparkConstString property, SparkHandle value);
SPARKAPI SparkVoid SPARKCALL SparkRenderGui(SparkGuiElement root);

SPARKAPI SparkAIBehavior SPARKCALL SparkCreateAIBehavior(SparkConstString type);
SPARKAPI SparkVoid SPARKCALL SparkDestroyAIBehavior(SparkAIBehavior behavior);
SPARKAPI SparkResult SPARKCALL SparkSetAIBehavior(SparkEntity entity, SparkAIBehavior behavior);

SPARKAPI SparkParticleEmitter SPARKCALL SparkCreateParticleEmitter();
SPARKAPI SparkVoid SPARKCALL SparkDestroyParticleEmitter(SparkParticleEmitter emitter);
SPARKAPI SparkResult SPARKCALL SparkSetParticleEmitterProperties(SparkParticleEmitter emitter /* properties */);
SPARKAPI SparkVoid SPARKCALL SparkEmitParticles(SparkParticleEmitter emitter, SparkSize count);

SPARKAPI SparkFont SPARKCALL SparkLoadFont(SparkConstString filePath, SparkScalar size);
SPARKAPI SparkVoid SPARKCALL SparkUnloadFont(SparkFont font);
SPARKAPI SparkVoid SPARKCALL SparkRenderText(SparkText* text);

/* Miscellaneous utility functions */
SPARKAPI SparkVoid SPARKCALL SparkSetWindowTitle(SparkWindow window, SparkConstString title);
SPARKAPI SparkVoid SPARKCALL SparkSetWindowSize(SparkWindow window, SparkI32 width, SparkI32 height);
SPARKAPI SparkVoid SPARKCALL SparkGetWindowSize(SparkWindow window, SparkI32* width, SparkI32* height);

SPARKAPI SparkEcs SPARKCALL SparkCreateEcs();
SPARKAPI SparkVoid SPARKCALL SparkDestroyEcs(SparkEcs ecs);
SPARKAPI SparkEntity SPARKCALL SparkCreateEntity(SparkEcs ecs);
SPARKAPI SparkResult SPARKCALL SparkDestroyEntity(SparkEcs ecs, SparkEntity entity_id);
SPARKAPI SparkComponent SPARKCALL SparkCreateComponent(SparkConstString type,
	SparkConstString name,
	SparkHandle data,
	SparkFreeFunction destructor);
SPARKAPI SparkResult SPARKCALL SparkAddComponent(SparkEcs ecs, SparkEntity entity_id,
	SparkComponent component);
SPARKAPI SparkResult SPARKCALL SparkRemoveComponent(SparkEcs ecs, SparkEntity entity_id,
	SparkConstString component_type,
	SparkConstString component_name);
SPARKAPI SparkComponent SPARKCALL SparkGetComponent(SparkEcs ecs, SparkEntity entity_id,
	SparkConstString component_type,
	SparkConstString component_name);
SPARKAPI SparkVector SPARKCALL SparkGetAllComponentsByType(SparkEcs ecs, SparkConstString component_type);
SPARKAPI SparkVector SPARKCALL SparkGetAllComponentsByEntity(SparkEcs ecs,
	SparkEntity entity_id);
SPARKAPI SparkResult SPARKCALL SparkAddSystem(SparkEcs ecs, SparkSystem system);
SPARKAPI SparkResult SPARKCALL SparkRemoveSystem(SparkEcs ecs, SparkSystem system);
SPARKAPI SparkResult SPARKCALL SparkStartEcs(SparkEcs ecs);
SPARKAPI SparkResult SPARKCALL SparkUpdateEcs(SparkEcs ecs, SparkF32 delta);
SPARKAPI SparkResult SPARKCALL SparkStopEcs(SparkEcs ecs);
SPARKAPI SparkResult SPARKCALL SparkRemoveAllEntityComponents(SparkEcs ecs,
	SparkEntity entity_id);

SPARKAPI SparkEventHandler SPARKCALL SparkDefaultEventHandler();
SPARKAPI SparkEventHandler SPARKCALL SparkCreateEventHandler(
	SparkEventHandlerFunction functions[], SparkSize function_count);
SPARKAPI SparkResult SPARKCALL SparkDestroyEventHandler(SparkEventHandler event_handler);
SPARKAPI SparkResult SPARKCALL SparkAddEventListener(
	SparkEventHandler event_handler, SparkEventType event_type,
	SparkApplicationEventFunction function);
SPARKAPI SparkResult SPARKCALL SparkRemoveEventListener(
	SparkEventHandler event_handler, SparkEventType event_type,
	SparkApplicationEventFunction function);
SPARKAPI SparkResult SPARKCALL SparkAddQueryEventListener(
	SparkEventHandler event_handler, SparkEventType event_type,
	SparkConstString component_type,
	SparkApplicationQueryEventFunction function);
SPARKAPI SparkResult SPARKCALL SparkRemoveQueryEventListener(
	SparkEventHandler event_handler, SparkEventType event_type,
	SparkConstString component_type,
	SparkApplicationQueryEventFunction function);
SPARKAPI SparkResult SPARKCALL SparkDispatchEvent(SparkEventHandler event_handler,
	SparkEvent event);
SPARKAPI SparkEvent SPARKCALL SparkCreateEvent(SparkEventType event_type,
	SparkHandle event_data,
	SparkFreeFunction destructor);
SPARKAPI SparkEvent SPARKCALL SparkCreateEventT(SparkEventType event_type,
	SparkHandle event_data,
	SparkFreeFunction destructor,
	SparkConstString time_stamp);
SPARKAPI SparkResult SPARKCALL SparkDestroyEvent(SparkEvent event);

SPARKAPI SparkWindowData SPARKCALL SparkCreateWindowData(SparkConstString title,
	SparkI32 width, SparkI32 height,
	SparkBool vsync);
SPARKAPI SparkVoid SPARKCALL SparkDestroyWindowData(SparkWindowData window_data);
SPARKAPI SparkWindow SPARKCALL SparkCreateWindow(SparkWindowData window_data);
SPARKAPI SparkVoid SPARKCALL SparkDestroyWindow(SparkWindow window);

SPARKAPI SparkRenderer SPARKCALL SparkCreateRenderer();
SPARKAPI SparkVoid SPARKCALL SparkDestroyRenderer(SparkRenderer renderer);

SPARKAPI SparkThreadPool SPARKCALL SparkCreateThreadPool(SparkSize thread_count);
SPARKAPI SparkVoid SPARKCALL SparkDestroyThreadPool(SparkThreadPool pool);
SPARKAPI SparkTaskHandle SPARKCALL SparkAddTaskThreadPool(SparkThreadPool pool,
	SparkThreadFunction function,
	SparkHandle arg);
SPARKAPI SparkBool SPARKCALL SparkIsTaskDone(SparkTaskHandle task);
SPARKAPI SparkResult SPARKCALL SparkWaitTask(SparkTaskHandle task);
SPARKAPI SparkVoid SPARKCALL SparkTaskDestroy(SparkTaskHandle task);

SPARKAPI SparkServer SPARKCALL SparkCreateServer(SparkThreadPool tp, SparkU16 port, SparkServerReceiveCallback callback);
SPARKAPI SparkVoid SPARKCALL SparkDestroyServer(SparkServer server);
SPARKAPI SparkResult SPARKCALL SparkStartServer(SparkServer server);
SPARKAPI SparkResult SPARKCALL SparkStopServer(SparkServer server);
SPARKAPI SparkResult SPARKCALL SparkSendToClient(SparkServer server, SparkClientConnection client, SparkEnvelope* envelope);
SPARKAPI SparkResult SPARKCALL SparkBroadcast(SparkServer server, SparkEnvelope* envelope);

SPARKAPI SparkClient SPARKCALL SparkCreateClient(SparkThreadPool tp, SparkConstString address, SparkU16 port, SparkClientReceiveCallback callback);
SPARKAPI SparkVoid SPARKCALL SparkDestroyClient(SparkClient client);
SPARKAPI SparkResult SPARKCALL SparkConnectClient(SparkClient client);
SPARKAPI SparkResult SPARKCALL SparkDisconnectClient(SparkClient client);
SPARKAPI SparkResult SPARKCALL SparkSendToServer(SparkClient client, SparkEnvelope* envelope);

SPARKAPI SparkResult SPARKCALL SparkSerializeEnvelope(SparkEnvelope* envelope, SparkBuffer* buffer, SparkSize* size);
SPARKAPI SparkResult SPARKCALL SparkDeserializeEnvelope(SparkBuffer buffer, SparkSize size, SparkEnvelope* envelope);

SPARKAPI SparkApplication SPARKCALL SparkCreateApplication(SparkWindow window, SparkSize thread_count);
SPARKAPI SparkVoid SPARKCALL SparkDestroyApplication(SparkApplication app);
SPARKAPI SparkResult SPARKCALL SparkUpdateApplication(SparkApplication app);
SPARKAPI SparkResult SPARKCALL SparkDispatchEventApplication(SparkApplication app,
	SparkEvent event);
SPARKAPI SparkResult SPARKCALL SparkAddStartFunctionApplication(
	SparkApplication app, SparkApplicationStartFunction function);
SPARKAPI SparkResult SPARKCALL SparkAddUpdateFunctionApplication(
	SparkApplication app, SparkApplicationUpdateFunction function);
SPARKAPI SparkResult SPARKCALL SparkAddStopFunctionApplication(
	SparkApplication app, SparkApplicationStopFunction function);
SPARKAPI SparkResult SPARKCALL SparkAddEventFunctionApplication(
	SparkApplication app, SparkEventType event_type,
	SparkApplicationEventFunction function);
SPARKAPI SparkResult SPARKCALL SparkAddQueryFunctionApplication(
	SparkApplication app, SparkConstString component_type,
	SparkApplicationQueryFunction function);
SPARKAPI SparkResult SPARKCALL SparkAddQueryEventFunctionApplication(
	SparkApplication app, SparkEventType event_type,
	SparkConstString component_type,
	SparkApplicationQueryEventFunction function);
SPARKAPI SparkResult SPARKCALL SparkStartApplication(SparkApplication app);

#pragma endregion

#pragma region ASSERTS

#define SPARK_ASSERT(condition, message)                                       \
  if (!(condition)) {                                                          \
    assert(SPARK_FALSE &&message);                                             \
  }
#define SPARK_ASSERT_NULL(pointer)                                             \
  SPARK_ASSERT(pointer != SPARK_NULL, "Pointer is null")
#define SPARK_ASSERT_NOT_NULL(pointer)                                         \
  SPARK_ASSERT(pointer != SPARK_NULL, "Pointer is not null")
#define SPARK_ASSERT_SUCCESS(result)                                           \
  SPARK_ASSERT(result == SPARK_SUCCESS, "Result is success")
#define SPARK_ASSERT_FAILURE(result)                                           \
  SPARK_ASSERT(result == SPARK_FAILURE, "Result is failure")
#define SPARK_ASSERT_VALID(result)                                             \
  SPARK_ASSERT(result == SPARK_VALID, "Result is valid")
#define SPARK_ASSERT_INVALID(result)                                           \
  SPARK_ASSERT(result == SPARK_INVALID, "Result is invalid")
#define SPARK_ASSERT_NOT_IMPLEMENTED(result)                                   \
  SPARK_ASSERT(result == SPARK_NOT_IMPLEMENTED, "Result is not implemented")
#define SPARK_ASSERT_NULL_OR_VALID(result)                                     \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_VALID,                  \
               "Result is null or valid")
#define SPARK_ASSERT_NULL_OR_INVALID(result)                                   \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_INVALID,                \
               "Result is null or invalid")
#define SPARK_ASSERT_NULL_OR_SUCCESS(result)                                   \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_SUCCESS,                \
               "Result is null or success")
#define SPARK_ASSERT_NULL_OR_FAILURE(result)                                   \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_FAILURE,                \
               "Result is null or failure")
#define SPARK_ASSERT_NULL_OR_PENDING(result)                                   \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_PENDING,                \
               "Result is null or pending")
#define SPARK_ASSERT_NULL_OR_IN_PROGRESS(result)                               \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_IN_PROGRESS,            \
               "Result is null or in progress")
#define SPARK_ASSERT_NULL_OR_COMPLETE(result)                                  \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_COMPLETE,               \
               "Result is null or complete")
#define SPARK_ASSERT_NULL_OR_TIMEOUT(result)                                   \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_TIMEOUT,                \
               "Result is null or timeout")
#define SPARK_ASSERT_NULL_OR_CANCELLED(result)                                 \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_CANCELLED,              \
               "Result is null or cancelled")
#define SPARK_ASSERT_NULL_OR_NOT_IMPLEMENTED(result)                           \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_NOT_IMPLEMENTED,        \
               "Result is null or not implemented")
#define SPARK_ASSERT_NULL_OR_ACCESS_DENIED(result)                             \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_ACCESS_DENIED,          \
               "Result is null or access denied")
#define SPARK_ASSERT_NULL_OR_NOT_FOUND(result)                                 \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_NOT_FOUND,              \
               "Result is null or not found")
#define SPARK_ASSERT_NULL_OR_BUSY(result)                                      \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_BUSY,                   \
               "Result is null or busy")
#define SPARK_ASSERT_NULL_OR_OVERLOADED(result)                                \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_OVERLOADED,             \
               "Result is null or overloaded")
#define SPARK_ASSERT_NULL_OR_DISCONNECTED(result)                              \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_DISCONNECTED,           \
               "Result is null or disconnected")
#define SPARK_ASSERT_NULL_OR_CONNECTED(result)                                 \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_CONNECTED,              \
               "Result is null or connected")
#define SPARK_ASSERT_NULL_OR_RETRY(result)                                     \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_RETRY,                  \
               "Result is null or retry")
#define SPARK_ASSERT_NULL_OR_DEPRECATED(result)                                \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_DEPRECATED,             \
               "Result is null or deprecated")
#define SPARK_ASSERT_NULL_OR_UNSUPPORTED(result)                               \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_UNSUPPORTED,            \
               "Result is null or unsupported")
#define SPARK_ASSERT_NULL_OR_UNINITIALIZED(result)                             \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_UNINITIALIZED,          \
               "Result is null or uninitialized")
#define SPARK_ASSERT_NULL_OR_DISABLED(result)                                  \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_DISABLED,               \
               "Result is null or disabled")
#define SPARK_ASSERT_NULL_OR_READ_ONLY(result)                                 \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_READ_ONLY,              \
               "Result is null or read only")
#define SPARK_ASSERT_NULL_OR_WRITE_ONLY(result)                                \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_WRITE_ONLY,             \
               "Result is null or write only")
#define SPARK_ASSERT_NULL_OR_OUT_OF_MEMORY(result)                             \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_OUT_OF_MEMORY,          \
               "Result is null or out of memory")
#define SPARK_ASSERT_NULL_OR_OVERFLOW(result)                                  \
  SPARK_ASSERT(result == SPARK_NULL || result == SPARK_OVERFLOW,               \
               "Result is null or overflow")

#define SPARK_CRASH_PROGRAM(reason)                                            \
  SPARK_ASSERT(SPARK_FALSE, "Program was forcibly closed for: " #reason)

#define SPARK_UNIMPLIMENTED SPARK_CRASH_PROGRAM("Unimplemented function!");

#pragma endregion

#pragma region ALIASES

#if defined(SPARK_DEFINE_BASIC_ALIASES) || defined(SPARK_DEFINE_ALL_ALIASES)

typedef SparkU8 u8;
typedef SparkI8 i8;
typedef SparkU16 u16;
typedef SparkI16 i16;
typedef SparkU32 u32;
typedef SparkI32 i32;
typedef SparkU64 u64;
typedef SparkI64 i64;
typedef SparkF32 f32;
typedef SparkF64 f64;
typedef SparkBool bool_t;
typedef SparkResult result;
typedef SparkError error;
typedef SparkVoid void_t;
typedef SparkHandle handle_t;
typedef SparkString string_t;
typedef SparkConstString const_string_t;
typedef SparkBuffer buffer_t;
typedef SparkConstBuffer const_buffer_t;
typedef SparkSize size_t;
typedef SparkIndex index_t;
typedef SparkCount count_t;
typedef SparkOffset offset_t;
typedef SparkTime stime_t;
typedef SparkDuration duration_t;
typedef SparkFrequency frequency_t;
typedef SparkRate rate_t;

#endif

#if defined(SPARK_DEFINE_ALIASES) || defined(SPARK_DEFINE_ALL_ALIASES)

typedef SparkType Type;
typedef SparkError Error;
typedef SparkAccess Access;
typedef SparkMouseButton MouseButton;
typedef SparkKey Key;
typedef SparkModifier Modifier;
typedef SparkAction Action;
typedef SparkCursor Cursor;
typedef SparkEventType EventType;
typedef SparkShaderType ShaderType;
typedef SparkPrimitiveType PrimitiveType;
typedef SparkBlendMode BlendMode;
typedef SparkTextureFilter TextureFilter;
typedef SparkLogLevel LogLevel;
typedef SparkRenderAPI RenderAPI;

typedef SparkEventDataKeyPressed EventDataKeyPressed;
typedef SparkEventDataKeyReleased EventDataKeyReleased;
typedef SparkEventDataMouseMoved EventDataMouseMoved;
typedef SparkEventDataMouseButtonPressed EventDataMouseButtonPressed;
typedef SparkEventDataMouseButtonReleased EventDataMouseButtonReleased;
typedef SparkEventDataMouseScrolled EventDataMouseScrolled;
typedef SparkEventDataWindowResized EventDataWindowResized;

typedef SparkAllocateFunction AllocateFunction;
typedef SparkReallocateFunction ReallocateFunction;
typedef SparkFreeFunction FreeFunction;
typedef SparkHashFunction HashFunction;
typedef SparkSystemStartFunction SystemStartFunction;
typedef SparkSystemUpdateFunction SystemUpdateFunction;
typedef SparkSystemStopFunction SystemStopFunction;

typedef SparkAllocator Allocator;
typedef SparkVector Vector;
typedef SparkList List;
typedef SparkMap Map;
typedef SparkHashMap HashMap;
typedef SparkSet Set;
typedef SparkHashSet HashSet;
typedef SparkQueue Queue;
typedef SparkStack Stack;

typedef SparkEntity Entity;
typedef SparkComponentArray ComponentArray;
typedef SparkComponent Component;
typedef SparkSystem System;
typedef SparkEcs Ecs;
typedef SparkEventHandler EventHandler;
typedef SparkResource Resource;
typedef SparkResourceLoader ResourceLoader;
typedef SparkResourceRegistry ResourceRegistry;
typedef SparkWindowData WindowData;
typedef SparkWindow Window;
typedef SparkRenderer Renderer;
typedef SparkEvent Event;
typedef SparkEventHandler EventHandler;
typedef SparkClientConnection ClientConnection;
typedef SparkEnvelope Envelope;
typedef SparkThreadPool ThreadPool;
typedef SparkTaskHandle TaskHandle;
typedef SparkServer Server;
typedef SparkClient Client;
typedef SparkFileSerializer FileSerializer;
typedef SparkFileDeserializer FileDeserializer;
typedef SparkApplication Application;

#define Vector(type) SparkVector
#define List(type) SparkList
#define Map(key, value) SparkMap
#define HashMap(key, value) SparkHashMap
#define Set(type) SparkSet
#define HashSet(type) SparkHashSet
#define Queue(type) SparkQueue
#define Stack(type) SparkStack

#endif

#if defined(SPARK_DEFINE_FUNCTION_ALIASES) || defined(SPARK_DEFINE_ALL_ALIASES)

#define Log SparkLog

#define TypeToString SparkTypeToString
#define StringToType SparkStringToType
#define ErrorToString SparkErrorToString
#define StringToError SparkStringToError
#define CheckSuccess SparkCheckSuccess
#define AccessToString SparkAccessToString
#define StringToAccess SparkStringToAccess
#define MouseButtonToString SparkMouseButtonToString
#define StringToMouseButton SparkStringToMouseButton
#define KeyToString SparkKeyToString
#define StringToKey SparkStringToKey
#define ModifierToString SparkModifierToString
#define StringToModifier SparkStringToModifier
#define ActionToString SparkActionToString
#define StringToAction SparkStringToAction
#define CursorToString SparkCursorToString
#define StringToCursor SparkStringToCursor
#define EventTypeToString SparkEventTypeToString
#define StringToEventType SparkStringToEventType
#define ShaderTypeToString SparkShaderTypeToString
#define StringToShaderType SparkStringToShaderType
#define PrimitiveTypeToString SparkPrimitiveTypeToString
#define StringToPrimitiveType SparkStringToPrimitiveType
#define BlendModeToString SparkBlendModeToString
#define StringToBlendMode SparkStringToBlendMode
#define TextureFilterToString SparkTextureFilterToString
#define StringToTextureFilter SparkStringToTextureFilter
#define LogLevelToString SparkLogLevelToString
#define StringToLogLevel SparkStringToLogLevel
#define RenderAPIToString SparkRenderAPIToString
#define StringToRenderAPI SparkStringToRenderAPI

#define Allocate SparkAllocate
#define Reallocate SparkReallocate
#define Free SparkFree
#define CreateAllocator SparkCreateAllocator
#define DestroyAllocator SparkDestroyAllocator
#define DefaultAllocator SparkDefaultAllocator

#define DefaultVector SparkDefaultVector
#define CreateVector SparkCreateVector
#define DestroyVector SparkDestroyVector
#define GetElementVector SparkGetElementVector
#define PushBackVector SparkPushBackVector
#define PopBackVector SparkPopBackVector
#define InsertVector SparkInsertVector
#define RemoveVector SparkRemoveVector
#define EraseVector SparkEraseVector
#define SetVector SparkSetVector
#define ResizeVector SparkResizeVector
#define ClearVector SparkClearVector

#define DefaultList SparkDefaultList
#define CreateList SparkCreateList
#define DestroyList SparkDestroyList
#define GetElementList SparkGetElementList
#define PushList SparkPushBackList
#define PopList SparkPopBackList
#define InsertList SparkInsertList
#define RemoveList SparkRemoveList
#define SetList SparkSetList
#define ClearList SparkClearList

#define DefaultMap SparkDefaultMap
#define CreateMap SparkCreateMap
#define DestroyMap SparkDestroyMap
#define GetElementMap SparkGetElementMap
#define InsertMap SparkInsertMap
#define RemoveMap SparkRemoveMap
#define SetMap SparkSetMap
#define ClearMap SparkClearMap

#define DefaultHashMap SparkDefaultHashMap
#define CreateHashMap SparkCreateHashMap
#define DestroyHashMap SparkDestroyHashMap
#define GetElementHashMap SparkGetElementHashMap
#define InsertHashMap SparkInsertHashMap
#define RemoveHashMap SparkRemoveHashMap
#define SetHashMap SparkSetHashMap
#define ClearHashMap SparkClearHashMap

#define DefaultSet SparkDefaultSet
#define CreateSet SparkCreateSet
#define DestroySet SparkDestroySet
#define GetElementSet SparkGetElementSet
#define InsertSet SparkInsertSet
#define RemoveSet SparkRemoveSet
#define ContainsSet SparkContainsSet
#define ClearSet SparkClearSet

#define DefaultHashSet SparkDefaultHashSet
#define CreateHashSet SparkCreateHashSet
#define DestroyHashSet SparkDestroyHashSet
#define InsertHashSet SparkInsertHashSet
#define RemoveHashSet SparkRemoveHashSet
#define ContainsHashSet SparkContainsHashSet
#define ClearHashSet SparkClearHashSet

#define DefaultQueue SparkDefaultQueue
#define CreateQueue SparkCreateQueue
#define DestroyQueue SparkDestroyQueue
#define GetBackQueue SparkGetBackQueue
#define GetFrontQueue SparkGetFrontQueue
#define EnqueueQueue SparkEnqueueQueue
#define DequeueQueue SparkDequeueQueue
#define ClearQueue SparkClearQueue

#define DefaultStack SparkDefaultStack
#define CreateStack SparkCreateStack
#define DestroyStack SparkDestroyStack
#define GetTopStack SparkGetTopStack
#define PushStack SparkPushStack
#define PopStack SparkPopStack
#define ClearStack SparkClearStack

#define CreateEcs SparkCreateEcs
#define DestroyEcs SparkDestroyEcs
#define CreateEntity SparkCreateEntity
#define DestroyEntity SparkDestroyEntity
#define AddComponent SparkAddComponent
#define CreateComponent SparkCreateComponent
#define RemoveComponent SparkRemoveComponent
#define GetComponent SparkGetComponent
#define AddSystem SparkAddSystem
#define RemoveSystem SparkRemoveSystem
#define StartEcs SparkStartEcs
#define UpdateEcs SparkUpdateEcs
#define StopEcs SparkStopEcs

#define CreateEventHandler SparkCreateEventHandler
#define DestroyEventHandler SparkDestroyEventHandler
#define AddEventListener SparkAddEventListener
#define RemoveEventListener SparkRemoveEventListener
#define DispatchEvent SparkDispatchEvent
#define CreateEvent SparkCreateEvent
#define DestroyEvent SparkDestroyEvent

#define CreateWindowData SparkCreateWindowData
#define DestroyWindowData SparkDestroyWindowData
#define CreateWindow SparkCreateWindow
#define DestroyWindow SparkDestroyWindow

#define CreateRenderer SparkCreateRenderer
#define DestroyRenderer SparkDestroyRenderer

#define CreateFileSerializer SparkCreateFileSerializer
#define DestroyFileSerializer SparkDestroyFileSerializer
#define SerializeRawData SparkSerializeRawData
#define SerializeData SparkSerializeData
#define SerializeHeader SparkSerializeHeader
#define CreateFileDeserializer SparkCreateFileDeserializer
#define DestroyFileDeserializer SparkDestroyFileDeserializer
#define DeserializeRawData SparkDeserializeRawData
#define DeserializeData SparkDeserializeData
#define DeserializeHeader SparkDeserializeHeader
#define DeserializeString SparkDeserializeString
#define DeserializeTrivial SparkDeserializeTrivial
#define Serialize SparkSerialize
#define Deserialize SparkDeserialize

#define CreateClient SparkCreateClient
#define DestroyClient SparkDestroyClient
#define ConnectClient SparkConnectClient
#define DisconnectClient SparkDisconnectClient
#define SendToServer SparkSendToServer
#define CreateServer SparkCreateServer
#define DestroyServer SparkDestroyServer
#define StartServer SparkStartServer
#define StopServer SparkStopServer
#define SendToClient SparkSendToClient
#define Broadcast SparkBroadcast

#define CreateApplication SparkCreateApplication
#define DestroyApplication SparkDestroyApplication
#define UpdateApplication SparkUpdateApplication
#define AddEventFunctionApplication SparkAddEventFunctionApplication
#define DispatchEventApplication SparkDispatchEventApplication
#define StartApplication SparkStartApplication
#define AddStartFunctionApplication SparkAddStartFunctionApplication
#define AddUpdateFunctionApplication SparkAddUpdateFunctionApplication
#define AddStopFunctionApplication SparkAddStopFunctionApplication
#define AddEventFunctionApplication SparkAddEventFunctionApplication
#define AddQueryFunctionApplication SparkAddQueryFunctionApplication
#define AddQueryEventFunctionApplication SparkAddQueryEventFunctionApplication

#endif

#pragma endregion

/*
#ifdef __cplusplus
}
#endif
*/
#endif /* SPARK_H */